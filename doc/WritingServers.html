<HTML><HEAD>
<TITLE>Writing a Server for Twisted</TITLE>
</HEAD>
<BODY>
<H1>Writing Servers</H1>

<H2>Overview</H2>

<p>Twisted is a framework designed to be very flexible and let you write 
powerful servers. The cost of this flexibility is a few layers in the way to 
writing your server.</P>

<p>At the base, the place where you actually implement the protocol 
parsing and handling, is the protocol handler class. This class will usually be 
decended 
from <CODE>twisted.protocols.protocol.Protocol</CODE>. 
Most protocol handlers inherit either 
from this class or from one of its convenience children. An instance of the 
protocol class will be instantiated per-connection, on demand, and it will go 
away when the connection is finished. This means that persistent configuration 
is not saved in the <CODE>Protocol</CODE>.</P>


<p>The persistent configuration is kept in a Factory class, which usually 
inherits from twisted.protocol.protocol.Factory. The default factory class 
just  instantiates each Protocol, and then sets on it an attribute called 
<CODE>factory</CODE> which points to itself. This lets every 
<CODE>Protocol</CODE> access, and possibly modify, 
the persistent configuration.</P>

<p>It is frequently needed to serve the same thing on two or more different 
ports or network addresses. This is why the Factory does not listen to 
connections, 
and in fact does not know anything about the network. This is the job of 
a Port class. Usually, the class twisted.internet.tcp.Port will be used, 
but there are several alternatives like twisted.internet.udp.Port and 
twisted.internet.ssl.Port.</CODE></P>

<p>Because of this multi-faceted aspect to writing servers, it is useful 
to have some place where all this things are bound together - using a 
specific Protocol class, with a specially initialized factory and a 
specific network interface on a specific port. For that, the twisted.tap 
package exists, which records "common server deployments". It creates 
a TAP (Twisted Application Pickle) which keeps the configuration information 
for a specific server.</P>

<p>So, in conclusion - most often, you will just have to write your Protocol 
class (which might get complicated, and you may want to write auxiliary classes 
for it) and then write a twisted.tap submodule which programmatically explains 
how to use this class.</P>

<p>This document will explain each step of the way.</P>

<H2>Protocols</H2>

<p>As mentioned above, this, along with auxiliary classes and functions, is where 
most of the code is. A Twisted protocol handles data in an asynchronous 
manner. What this means is that the protocol never waits for an event, 
but rather responds to events as they arrive from the network. 
<p>Here is a simple example:

<PRE>
from twisted.protocols.protocol import Protocol 
class Echo(Protocol):

    def dataReceived(self, data):
        self.transport.write(data)
</PRE>

<p>This is one of the simplest protocols. It simply writes back whatever 
is written to it. There are many events it does not respond to. Here 
is an example of a Protocol responding to another event:</P>

<PRE>
from twisted.protocols.protocol import Protocol 
class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n") 
        self.transport.loseConnction()
</PRE>

<p>This protocol responds to the initial connection with a well known quote, 
and then terminates the connection.</P>

<p>The connectionMade event is usually where set up of the connection object 
happens, as well as any initial greetings (as in the QOTD protocol above, 
which is actually based on RFC 865). The connectionLost event is where 
tearing down of any Protocol-specific objects is done. Here is an example:</P>

<PRE>
from twisted.protocols.protocol import Protocol 
class Echo(Protocol):

    def connectionMade(self):
        self.factory.numProtocols = self.factory.numProtocols+1 
        if self.factory.numProtocols&gt;100:
            self.transport.write("Too many connections, try later") 
            self.transport.loseConnection()

    def connectionLost(self):
        self.factory.numProtocols = self.factory.numProtocols-1

    def dataReceived(self, data):
        self.transport.write(data)
</PRE>

<p>Here <CODE>connectionMade</CODE> and <CODE>connectionLost</CODE>
cooperate to keep a count of the 
active protocols in the factory. <CODE>connectionMade</CODE> immediately 
closes the connection if there are too many active protocols.</P>

<H3>Using the Protocol -- An Interlude</H3>

<P>In this section, I will explain how to test your protocol easily.
You'll still need to read the rest of the document to run a production-grade
Twisted server, though.</P>

<P>Here is code that will run the QOTD server discussed earlier</P>

<PRE>
from twisted.protocols.protocol import Protocol, Factory
from twisted.internet.main import Application

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write("An apple a day keeps the doctor away\r\n") 
        self.transport.loseConnction()

# Next lines are magic:
factory = Factory()
factory.protocol = QOTD
app = Application("QOTD")
# 8007 is the port you want to run under. Choose something >1024
app.listenTCP(8007, factory)
app.run()
</PRE>

<P>Don't worry about the last 6 magic lines -- you will understand
what they do later in the document.</P>

<H3>Helper Protocols</H3>

<P>Many protocols build upon similar lower-level abstraction. The most popular
in internet protocols is being line-based. Lines are usually terminated with
a CR-LF combinations.</P>

<P>However, quite a few protocols are mixed - they have line-based sections
and then raw data sections. Examples include HTTP/1.1 and the Freenet 
protocol.</P>

<P>For those cases, there is the <CODE>LineReceiver</CODE> protocol.
This protocol dispatches to two different event handlers - 
<CODE>lineReceived</CODE> and <CODE>rawDataReceived</CODE>. By default,
only <CODE>lineReceived</CODE> will be called, once for each line. However,
if <CODE>setRawMode</CODE> is called, the protocol will call 
<CODE>rawDataReceived</CODE> until <CODE>setLineMode</CODE> is called again.</P>

<P>Here is an example for a simple use of the line receiver:</P>

<PRE>
from twisted.protocols.basic import LineReceiver

class Answer(LineReceiver):

    answers = {'How are you?': 'Fine', None : 'I don't know what you mean'}

    def lineReceived(self, line):
        if self.answers.has_key(line):
            self.sendLine(self.answers[line])
        else:
            self.sendLine(self.answers[None])
</PRE>

<P>Note that the delimiter is not part of the line.</P>

<P>Several other, less popular, helpers exist, such as a netstring based
protocol and a prefixed-message-length protocol.</P>

<H3>State Machines</H3>

<P>Many Twisted protocol handlers need to write a state machine to record
the state they are at. Here are some pieces of advice which help to write
state machines:<P>

<UL>
<LI>Don't write big state machines. Prefer to write a state machine which
    deals with one level of abstraction at a time.
<LI>Use Python's dynamicity to create open ended state machines. See, for
    example, the code for the SMTP client.
<LI>Don't mix application-specific code with Protocol handling code. When
    the protocol handler has to make an application-specific call, keep it
    as a method call.
</UL>

<H2>Factories</H2>

<P>As mentioned before, usually the class 
<CODE>twisted.internet.protocols.protocol.Protocol</P> works, and there
is no need to override it. However, sometimes there can be factory-specific
configuration of the protocols, or other considerations. In those cases,
there is a need to subclass <CODE>Factory</CODE>.</P>

<P>For a factory which simply instantiates instances of a specific protocol
class, simply instantiate <CODE>Factory</CODE>, and sets its "protocol"
attribute:</P>

<PRE>
from twisted.internet.protocols.protocol import Factory
from twisted.internet.protocols.wire import Echo

myFactory = Factory()
myFactory.protocol = Echo
</PRE>

<P>If there is a need to easily construct factories for a specific 
configuration, a factory function is often useful:</P>

<PRE>
from twisted.internet.protocols.protocol import Factory, Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


def makeQOTDFactory(quote=None):
    factory = Factory()
    factory.protocol = QOTD
    factory.quote = quote or 'An apple a day keeps the doctor away'
    return factory
</PRE>

<P>A Factory has two methods to perform application-specific building
up and tearing down (since a Factory is frequently persisted, it is often
not appropriate to do them in __init__ or __del__, and would frequently
be too early or too late).</P>

<P>Here is an example of a factory which allows its Protocols to write
to a special log-file:</P>

<PRE>
from twisted.internet.protocols.protocol import Factory
from twisted.internet.protocols.basic import LineReceiver


class LoggingProtocol(LineReceiver):

    def lineReceived(self, line):
        self.factory.fp.write(line+'\n')


class LogfileFactory(Factory):

    protocol = LoggingProtocol

    def __init__(self, fileName):
        self.file = fileName

    def startFactory(self):
        self.fp = open(file, 'a')

    def stopFactory(self):
        self.fp.close()
</PRE>

<H3>Putting it All Together -- Another Interlude</H3>

<P>So, you know what factories are, and want to run the QOTD
with configurable quote server, do you? No problems, here is
an example.</P>

<PRE>
from twisted.internet.protocols.protocol import Factory, Protocol
from twisted.internet.main import Application

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


def makeQOTDFactory(quote=None):
    factory = Factory()
    factory.protocol = QOTD
    factory.quote = quote or 'An apple a day keeps the doctor away'
    return factory

app = Application("QOTD-with-factory")
app.listenTCP(8007, makeQOTDFactory("configurable quote"))
app.run()
</PRE>

<P>And that's it!</P>

<H2>Ports</H2>

<P>While more ports can be written, it is a less frequent operation
and so will not be discussed here. If there is a need to write another
Port, follow the example in <CODE>twisted.internet.tcp.Port.</CODE></P>

<P>Most code uses <CODE>twisted.internet.tcp.Port</CODE>s. These are
initialized with a factory and a port number:</P>

<PRE>
from twisted.internet.tcp import Port
from twisted.internet.protocols.protocol import Factory
from twisted.internet.protocols.basic import Echo

factory = Factory()
factory.protocol = Echo
port = Port(7, factory)
</PRE>

<P>Usually, code will not need to handle <CODE>Port</CODE>s directly.</P>

<H2><CODE>twisted.tap</CODE></H2>

<P>As seen, many times the interplays between a specific Protocol class
and a specific Factory class depend on quite a few attributes which all
need to be set correctly. The <CODE>twisted.tap</CODE> package allows
a programmer to document it programmatically, while giving a naive user
an easy way to generate configurations.</P>

<P>Let us assume that a module, <CODE>twisted.quote</CODE>, included
the following code, which has already been given as example:</P>

<PRE>
from twisted.internet.protocols.protocol import Factory, Protocol

class QOTD(Protocol):

    def connectionMade(self):
        self.transport.write(self.factory.quote+'\r\n')
        self.transport.loseConnection()


def makeQOTDFactory(quote=None):
    factory = Factory()
    factory.protocol = QOTD
    factory.quote = quote or 'An apple a day keeps the doctor away'
    return factory
</PRE>

<P>We want a user to be able to generate a quote server easily. He
should be able to give a quote, and optionally a port number. If
no port number is given, the server should listen on port 17, the one
mandated by the RFC.</P>

<P>We will have the configuration-creator accept the options <CODE>-q</CODE>
or <CODE>--quote</CODE> to set the quote, and <CODE>-p</CODE> or
<CODE>--port</CODE> to set the ports.</CODE></P>

<P>Here is an example (this code should be in twisted/tap/quote.py):</P>

<PRE>
from twisted.python import usage
from twisted.quote import makeQOTDFactory


class Options(usage.Options):

    synopsis = "Usage: mktap quote [options]"

    optStrings = [["port", "p", 17], ["quote", "q", None]]

    longdesc = "Quote server"


def getPorts(app, config):
    factory = makeQOTDFactory(config.quote)
    return [(int(config.port), factory)]
</PRE>

<H2>Putting it All Together</H2>

Well, now that you have all that, you're probably wondering, what do
we do now to actually run the server? Well, nothing could be simpler.

<PRE>
% mktap quote --quote "Twisted is coolness personified"
% su
# twistd -f quote.tap
# exit
%
</PRE>

You need to run <CODE>twistd</CODE> as root, because it needs to bind
to a privileged port. Don't worry -- it'll shed privileges and suid to
the user you ran <CODE>mktap</CODE> as soon as possible. It is not very 
hard to configure it to run as any other user:

<PRE>
% mktap --uid 33 --gid 33 quote --quote "Twisted is coolness personified"
% su
# twistd -f quote.tap
# exit
%
</PRE>

Will run it as <CODE>www-data</CODE> on Debian systems, for example.

</BODY></HTML>
