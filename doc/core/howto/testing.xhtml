<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Tips for writing tests for Twisted code</title>
  </head>

  <body>

<h1>Tips for writing tests for Twisted code</h1>

<h2>Trial basics</h2>

<p><strong>Trial</strong> is Twisted's testing framework.  It provides a library
for building test cases (similar to the Python standard library's
<code>unittest</code> module) and utility functions for working with the Twisted
environment in your tests, and a command-line utility for running your tests.
For instance, to run all the Twisted tests, do:</p>

<pre class="shell">
$ trial -R twisted
</pre>

<p>Refer to the Trial man page for other command-line options.</p>

<h2>Twisted-specific quirks: reactor, Deferreds, callLater</h2>

<p>The standard Python <code>unittest</code> framework, from which Trial is
derived, is ideal for testing code with a fairly linear flow of control.
Twisted is an asynchronous networking framework which provides a clean,
sensible way to establish functions that are run in response to events (like
timers and incoming data), which creates a highly non-linear flow of control.
Trial has a few extensions which help to test this kind of code. This section
provides some hints on how to use these extensions and how to best structure
your tests.</p>

<h3>Leave the Reactor as you found it</h3>

<p>Trial runs the entire test suite (over one thousand tests) in a single
process, with a single reactor. Therefore it is important that your test
leave the reactor in the same state as it found it. Leftover timers may
expire during somebody else's unsuspecting test. Leftover connection attempts
may complete (and fail) during a later test. These lead to intermittent
failures that wander from test to test and are very time-consuming to track
down.</p>

<p>Your test is responsible for cleaning up after itself. The
<code>tearDown</code> method is an ideal place for this cleanup code: it is
always run regardless of whether your test passes or fails (like a bare
<code>except</code> clause in a try-except construct). Exceptions in
<code>tearDown</code> are flagged as errors and flunk the test.</p>

<p><code>reactor.stop</code> is considered very harmful, and should only be used by
reactor-specific test cases which know how to restore the state that it
kills. If you must use reactor.run, use <code>reactor.crash</code> to stop it instead of
<code>reactor.stop</code>.</p>

<p>Calls to <code>reactor.callLater</code> create <code
class="API" base="twisted.internet.interfaces">IDelayedCall</code>s.  These need
to be run or cancelled during a test, otherwise they will outlive the test.
This would be bad, because they could interfere with a later test, causing
confusing failures in unrelated tests!  For this reason, Trial checks the
reactor to make sure there are no leftover <code class="API"
base="twisted.internet.interfaces">IDelayedCall</code>s in the reactor after a
test, and will fail the test if there are.</p>

<p>Similarly, sockets created during a test should be closed by the end of the
test.  This applies to both listening ports and client connections.  So, calls
to <code>reactor.listenTCP</code> (and <code>listenUNIX</code>, and so on)
return <code class="API"
base="twisted.internet.interfaces">IListeningPort</code>s, and these should be
cleaned up before a test ends by calling their <code class="API"
base="twisted.internet.interfaces.IListeningPort">stopListening</code> method
(note that this can return a Deferred, so you should <code>wait</code> on it to
make sure it has really stopped before the test ends.  Calls to
<code>reactor.connectTCP</code> return <code class="API"
base="twisted.internet.interfaces">IConnector</code>s, which should be cleaned
up by calling their <code class="API"
base="twisted.internet.interfaces.IConnector">disconnect</code> method.  Trial
will warn about unclosed sockets.</p>

<h3>deferredResult</h3>

<p>If your test creates a <code class="API"
base="twisted.internet.defer">Deferred</code> and simply wants to verify
something about its result, use <code class="API"
base="twisted.trial.util">deferredResult</code>. It will wait for the
Deferred to fire and give you the result. If the Deferred runs the errback
handler instead, it will raise an exception so your test can fail. Note that
the <em>only</em> thing that will terminate a <code>deferredResult</code>
call is if the Deferred fires; in particular, timers which raise exceptions
will not cause it to return.</p>

<h3>Waiting for Things</h3>

<p>The preferred way to run a test that waits for something to happen (always
triggered by other things that you have done) is to use a <code
class="python">while not self.done</code> loop that does <code
class="python">reactor.iterate(0.1)</code> at the beginning of each pass. The
<q>0.1</q> argument sets a limit on how long the reactor will wait to return
if there is nothing to do. 100 milliseconds is long enough to avoid spamming
the CPU while your timers wait to expire.</p>

<h3>Using Timers to Detect Failing Tests</h3>

<p>It is common for tests to establish some kind of fail-safe timeout that
will terminate the test in case something unexpected has happened and none of
the normal test-failure paths are followed. This timeout puts an upper bound
on the time that a test can consume, and prevents the entire test suite from
stalling because of a single test. This is especially important for the
Twisted test suite, because it is run automatically by the buildbot whenever
changes are committed to the Subversion repository.</p>

<p>Trial tests indicate they have failed by raising a FailTest exception
(self.fail and friends are just wrappers around this <code
class="python">raise</code> statement). Exceptions that are raised inside a
callRemote timer are caught and logged but otherwise ignored. Trial uses a
logging hook to notice when errors have been logged by the test that just
completed (so such errors will flunk the test), but this happens after the
fact: they will not be noticed by the main body of your test code. Therefore
callRemote timers can not be used directly to establish timeouts which
terminate and flunk the test.</p>

<p>The right way to implement this sort of timeout is to have a
<code>self.done</code> flag, and a while loop which iterates the reactor
until it becomes true. Anything that causes the test to be finished (success
<em>or</em> failure) can set self.done to cause the loop to exit.</p>

<p>Most of the code in Twisted is run by the reactor as a result of socket
activity. This is almost always started by Protocol.connectionMade or
Protocol.dataReceived (because the output side goes through a buffer which
queues data for transmission). Exceptions that are raised by code called in
this way (by the reactor, through doRead or doWrite) are caught, logged,
handed to connectionLost, and otherwise ignored.</p>

<p>This means that your Protocol's connectionLost method, if invoked because
of an exception, must also set this self.done flag. Otherwise the test will
not terminate.</p>

<p>Exceptions that are raised in a Deferred callback are turned into a
Failure and stashed inside the Deferred. When an errback handler is attached,
the Failure is given to it. If the Deferred goes out of scope while an error
is still pending, the error is logged just like exceptions that happen in
timers or protocol handlers. This will cause the current test to flunk
(eventually), but it is not checked until after the test fails. So again, it
is a good idea to add errbacks to your Deferreds that will terminate your
test's main loop.</p>

<p>Here is a brief example that demonstrates a few of these techniques.</p>

<pre class="python">
class MyTest(unittest.TestCase):
    def setUp(self):
        self.done = False
        self.failure = None

    def tearDown(self):
        self.server.stopListening()
        # TODO: also shut down client
        try:
            self.timeout.cancel()
        except (error.AlreadyCancelled, error.AlreadyCalled):
            pass

    def succeeded(self):
        self.done = True

    def failed(self, why):
        self.done = True
        self.failure = why

    def testServer(self):
        self.server = reactor.listenTCP(port, factory)
        self.client = reactor.connectTCP(port, factory)
        # you should give the factories a way to call our 'succeeded' or
        # 'failed' methods
        self.timeout = reactor.callLater(5, self.failed, "timeout")
        while not self.done:
            reactor.iterate(0.1)

        # we get here if the test is finished, for good or for bad
        if self.failure:
            self.fail(self.failure)
        # otherwise it probably passed. Cleanup will be done in tearDown()
</pre>

  </body>
</html>
