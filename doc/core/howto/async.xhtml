<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head><title>Asynchronous Programming</title></head>
<body>

<h1>Asynchronous Programming</h1>


<h2>Introduction</h2>

<h3>Waiting for answers</h3>

<p>A fundamental feature of network programming is that of waiting for data.
Imagine you have a function which sends an email summarising some information.
This function needs to connect to a remote server, wait for the remote server
to reply, check that the remote server can process the email, wait for the
reply, send the email, wait for the confirmation, and then disconnect.</p>

<p>Any one of these steps may take a long period of time. Your program might
use the simplest of all possible models, in which it actually sits and waits
for data to be sent and received, but in this case it has some very obvious
and basic limitations: it can't send many emails at once; and in fact it can't
do anything else while it is sending an email.</p>

<p>Hence, all but the simplest network programs avoid this model. You can use
one of several different models to allow your program to keep doing whatever
tasks it has on hand while it is waiting for something to happen before a
particular task can continue.</p>

<h3>Not waiting on data</h3>

<p>There are many ways to write network programs.  The main ones are:</p>

<ol>
    <li>handle each connection in a separate operating system process, in
    which case the operating system will take care of letting other processes
    run while one is waiting;</li>
    <li>handle each connection in a separate thread<span class="footnote">There
    are variations on this method, such
    as a limited-size pool of threads servicing all connections, which are
    essentially just optimizations of the same idea.</span> in which the
    threading framework takes care of letting other threads run while one is
    waiting; or</li>
    <li>use non-blocking system calls to handle all connections
        in one thread.</li>
</ol>

<h3>Non-blocking calls</h3>

<p>The normal model when using the Twisted framework is the third model:
non-blocking calls.</p>

<p>When dealing with many connections in one thread, the scheduling is the
responsibility of the application, not the operating system, and is usually
implemented by calling a registered function when each connection is ready to
for reading or writing -- commonly known as <b>asynchronous</b>,
<b>event-driven</b> or <b>callback-based</b> programming.</p>

<p>In this model, the earlier email sending function would work something
like this:</p>

<ol>
<li>it calls a connection function to connect to the remote server;</li>
<li>the connection function returns immediately, with the implication that the notify
the email sending library will be called when the connect has been made; and
<li>once the connection is made, the connect mechanism notifies the email
sending function that the connection is ready.</li>
</ol>

<p>What advantage does the above sequence have over our original blocking
sequence? The advantage is that while the email sending function can't do the
next part of its job until the connection is open, the rest of the program can
do other tasks, like begin the opening sequence for other email connections.
Hence, the entire program is not waiting for the connection.</p>

<h3>Advantages of asynchrony</h3>

<p>Multi-threaded programming is tricky, even with high level
abstractions, and Python's 
<a href="http://www.python.org/doc/current/api/threads.html">Global
Interpreter Lock</a> limits the potential performance gain. Forking
Python processes also has many disadvantages, such as Python's reference
counting not playing well with copy-on-write and problems with shared
state. Consequently, it was felt the best option was an event-driven
framework. A benefit of such an approach is that by letting other
event-driven frameworks take over the main loop, server and client
code are essentially the same -- making peer-to-peer a reality.</p>

<p>However, event-driven programming still contains some tricky
aspects. As each callback must be finished as soon as possible,
it is not possible to keep persistent state in function-local
variables. In addition, some programming techniques, such as
recursion, are impossible to use -- for example, this rules out protocol
handlers being recursive-descent parsers. Event-driven programming has
a reputation of being hard to use due to the frequent need to
write state machines. Twisted was built with the assumption
that with the right library, event-driven programming is easier
than multi-threaded programming.</p>

<p>Note that Twisted still allows the use of threads if you really 
need them, usually to interface with synchronous legacy code.  See 
<a href="threading.xhtml">Using Threads</a> for details.</p>

<h2>Async Design Issues</h2>

<p>In Python, code is often divided into a generic class calling
overridable methods which subclasses implement. In that, and similar,
cases, it is important to think about likely implementations. If it is
conceivable that an implementation might perform an action which takes
a long time (either because of network or CPU issues), then one should
design that method to be asynchronous. In general, this means to transform
the method to be callback based. In Twisted, it usually means returning
a <a href="defer.xhtml">Deferred</a>.</p>

<p>Since non-volatile state cannot be kept in local variables, because each
method must return quickly, it is usually kept in instance variables. In cases
where recursion would have been tempting, it is usually necessary to keep
stacks manually, using Python's list and the <code>.append</code> and
<code>.pop</code> method. Because those state machines frequently get
non-trivial, it is better to layer them such that each one state machine
does one thing -- converting events from one level of abstraction to the
next higher level of abstraction. This allows the code to be clearer, as
well as easier to debug.</p>

<h2>Using Reflection</h2>

<p>One consequence of using the callback style of programming is the
need to name small chunks of code. While this may seem like a trivial
issue, used correctly it can prove to be an advantage. If strictly
consistent naming is used, then much of the common code in parsers of
the form of if/else rules or long cases can be avoided. For example,
the SMTP client code has an instance variable which signifies what it
is trying to do. When receiving a response from the server, it just calls
the method <code>"do_%s_%s" % (self.state, responseCode)</code>. This
eliminates the requirement for registering the callback or adding to
large if/else chains. In addition, subclasses can easily override or
change the actions when receiving some responses, with no additional
harness code.  The SMTP client implementation can be found in 
<code>twisted/protocols/smtp.py</code>.</p>


</body></html>
