<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Using Perspective Broker: the walking tour</title>

<style src="stylesheet-unprocessed.css"></style>

</head>

<body>
<h1>Using Perspective Broker: the walking tour</h1>

<a  name="foreword"><h2>Foreword</h2></a>

<p>This document is intended to be a tutorial for getting familiar with
Twisted's <q>Perspective Broker</q> service. The framework is powerful and
flexible, and I could tell it was something I wanted to be able to use, but
I found it difficult to learn how to use it, either by reading the HOWTO
docs, the code's docstrings, or the few examples I could find. All of them
had an implicit assumption that the reader already understood some basic
concepts, an understanding I did not have. This is a recurring difficulty
with documentation: the only people who know enough to write good docs
already know too much to be able to guess what a beginner won't get. From
the documentation-writing point of view, this means that <q>ignorance</q> is a
valuable commodity: it lets you know what parts need to be documented
better, and which questions to ask.</p>

<p>I have found that trying to learn Twisted is a bit like looking at that
silhouette drawing that can either be seen as a vase or as two faces:
there's a cognitive leap you need to make that is difficult for some people
(certainly for me), but after you manage it, everything makes perfect sense
and you can easily see how all the parts fit together. I've found that when
I do finally manage to see the two faces (or the vase), it falls so strongly
into place that I find it hard to remember what I had been confused about
before. At that point I've used up my ignorance, and then find it hard to
figure out what hints or docs would have been useful to me when I got
stuck.</p>

<p>So I am writing this just after I hit this point of enlightenment with
Twisted, in the hope that I can document enough of the process I went
through to be useful to someone else following the same path.</p>

<p>What I have discovered is that, now (after I think I know what's going
on), the HOWTO docs that come with Twisted make much more sense to me. I
know that they didn't before. So perhaps I've already lost that precious
ignorance that makes it possible to write useful docs. But it seems that
this text overlaps the HOWTO docs in significant places. So perhaps this
document is best used in conjunction with the howtos.</p>


<a name="pb"><h2>Introduction: why use Perspective Broker?</h2></a>

<p>So, you've read through the <q>Writing Servers</q> page, and now you're a
skilled pro at implementing protocols by writing subclasses of
<code class="API" base="twisted.internet.protocol">Protocol</code>. You
discovered that most of /etc/services has
already been implemented somewhere in twisted/protocols/*.py, so you went
out to find new weird ones to write: an NTP server, a DHCP implementation,
TFTP, and then Gopher because you couldn't find anything else that needed
doing.</p>

<p>But suppose you find yourself in control of both ends of the wire: you
have two programs that need to talk to each other, and you get to use any
protocol you want. If you can think of your problem in terms of objects that
need to make method calls on each other, then chances are good that you can
use twisted's Perspective Broker protocol rather than trying to shoehorn
your needs into something like HTTP, or implementing yet another RPC
mechanism<span class="footnote">Most of Twisted is like this.  Hell, most of
unix is like this: if <em>you</em> think it would be useful, someone else has
probably thought that way in the past, and acted on it, and you can take
advantage of the tool they created to solve the same problem you're facing
now.</span>.</p>

<p>The Perspective Broker system (abbreviated <q>PB</q>, spawning numerous
sandwich-related puns) is based upon a few central concepts:</p>

<ul>

  <li><em>serialization</em>: taking fairly arbitrary objects and types,
  turning them into a chunk of bytes, sending them over a wire, then
  reconstituting them on the other end. By keeping careful track of object
  ids, the serialized objects can contain references to other objects and
  the remote copy will still be useful. </li>
  
  <li><em>remote method calls</em>: doing something to a local object and
  causing a method to get run on a distant one. The local object is called a
  <code class="API" base="twisted.spread.pb">RemoteReference</code>, and you
  <q>do something</q> by running its <code>.callRemote</code> method.
  </li>

</ul>

<p>This document will contain several examples that will (hopefully) appear
redundant and verbose once you've figured out what's going on. To begin
with, much of the code will just be labelled <q>magic</q>: don't worry about how
these parts work yet. It will be explained more fully later.</p>

<p>At several points there are footnotes that explain implementation details
or exceptions to the rules just presented. On your first pass through the
text, you should probably ignore these. Think of them as goodies to explore
later, after you've gotten the basic concepts down.</p>


<a name="roadmap"><h2>Class Roadmap</h2></a>

<p>To start with, here are the major classes involved in PB, with links to
the file where they are defined (all of which are under twisted/, of
course). Don't worry about understanding what they all do yet: it's easier
to figure them out through their interaction than explaining them one at a
time.</p>

<ul>

  <li><em><code class="API" base="twisted.internet.app">Application</code></em>
  : <code>internet/app.py</code></li>

  <li><em><code class="API" base="twisted.spread.pb">Service</code></em>
  : <code>spread/pb.py</code>, subclassed from
  <code class="API" base="twisted.cred.service">Service</code>
  in <code>cred/service.py</code></li>

  <li><em><code class="API" base="twisted.internet.app">MultiService</code></em>
  : <code>internet/app.py</code></li>

  <li><em><code class="API" base="twisted.internet.protocol">Factory</code></em>
  : <code>internet/protocol.py</code></li>

  <li><em><code class="API" base="twisted.spread.pb">BrokerFactory</code></em>
  : <code>spread/pb.py</code></li>

  <li><em><code class="API" base="twisted.spread.pb">Broker</code></em>
  : <code>spread/pb.py</code></li>

  <li><em><code class="API" base="twisted.spread.pb">AuthRoot</code></em>
  : <code>spread/pb.py</code></li>

</ul>

<p>Other classes that are involved at some point:</p>

<ul>

  <li> <em><code class="API" base="twisted.spread.pb">RemoteReference</code></em>
  : <code>spread/pb.py</code> </li>

  <li> <em><code class="API" base="twisted.spread">pb.Root</code></em>
  : <code>spread/pb.py</code>, actually defined as
  <code class="API" base="twisted.spread.flavors">Root</code>
  in <code>spread/flavors.py</code> </li>

  <li> <em><code class="API" base="twisted.spread">pb.Referenceable</code></em>
  : <code>spread/pb.py</code>, actually defined as
  <code class="API" base="twisted.spread.flavors">Referenceable</code>
  in <code>spread/flavors.py</code> </li>

</ul>

<p>Classes that get involved when you start to care about authorization and
security:</p>

<ul>
  <li><em><code class="API" base="twisted.cred.authorizer">Authorizer</code></em>
  : <code>cred/authorizer.py</code></li>
  
  <li><em><code class="API" base="twisted.cred.identity">Identity</code></em>
  : <code>cred/identity.py</code></li>

  <li><em><code class="API" base="twisted.spread.pb">Perspective</code></em>
  : <code>spread/pb.py</code>, subclassed from
  <code class="API" base="twisted.cred.perspective">Perspective</code>
  in <code>cred/perspective.py</code></li>

</ul>


<a name="pb/refactored"><h3>Why are there so many classes?</h3></a>

<p>It's easy to get confused by the large variety of classes, especially
when you see that certain functionality has been distributed up among
several small classes instead of being lumped into one. What you're seeing
is the result of several code refactorings by the highly trained engineers
of Twisted Matrix Laboratories. Kept undistracted in their cells, these
clever developers use precision machinery and the very latest technology to
painstakingly arrange and rearrange the Twisted class structure. They've
slaved away in the Engineering Sub-Basement, deep below the earth, until the
Twisted classes are to the point that that common cases are handled
completely by the default code, but yet the classes are arranged just right,
so that you and other developers can make useful changes by only modifying
one or two methods in your subclass.</p>

<p>Basically: the Twisted developers looked at the set of problems they were
trying to solve, and put together a scheme that took care of it. Then
someone else came along and said <q>great, but how do I use your framework to
solve this other problem too?</q>. Code gets added. Eventually someone looks at
the code and realizes that the needs imposed by the new problems can be
generalized, that a clean solution is to break up the functionality into two
parts: one that remains the same for both problems, and another that can be
changed (probably subclassed) to handle the unique needs of the second. The
imaginary dotted lines that break up the problem into smaller subproblems
have been rearranged to minimize the number of components that need to be
changed. When this is done without changing the overall behavior, it is
called Refactoring. (When it does change the behavior, it's called
Rewriting, and isn't nearly as cool). Repeat this cycle many times and you
get a collection of classes that can solve a wide variety of distributed
computing problems with a minimum of new code.</p>


<a name="pb/subclassing"><h3>So which ones am I supposed to subclass?</h3></a>

<p>That's a tricky one. Technically you can subclass anything you want, but
techically you could also write a whole new framework, which would just
waste a lot of time. Knowing which classes are useful to change (by making
subclasses) is one of the bits of knowledge you pick up after using Twisted
for a few weeks. Here are some hints to get started:</p>

<ul>

  <li><code class="API" base="twisted.internet.protocol">Protocol</code>:
  subclass this if you need to implement a new protocol on
  the wire, like HTTP or SMTP (except that almost all of the standard ones
  are already implemented). You might also subclass one of the standard
  implementations if you want to change its back-end behavior: make an SMTP
  server which actually stores the messages in files instead of mailing
  them, or a Finger server that returns random messages instead of current
  login status. </li>

  <li><code class="API" base="twisted.spread">pb.Root</code>, 
  <code class="API" base="twisted.spread">pb.Referenceable</code>: you'll
  subclass these to make remotely-referenceable objects using PB. You don't
  need to change any of the existing behavior, just inherit all of it and add
  the remotely-accessible methods that you want to export.</li>
  
  <li><code class="API" base="twisted.spread">pb.Perspective</code>, 
  <code class="API" base="twisted.spread">pb.Service</code>: you'll probably
  end up subclassing these when you get into PB programming (with
  authorization). There are a few methods you'll change, especially with
  regards to creating new Perspectives.</li>

  <li><code class="API" base="twisted.cred.authorizer">Authorizer</code>:
  subclass this if you want to get users from /etc/passwd,
  or a database, or LDAP, or other list of usernames and passwords.</li>

</ul>

<p>XXX: add lists of useful-to-override methods here</p>

<a name="pb/basic"><h2>Basic remote method invocation</h2></a>


<p>The first example to look at is a complete (although somewhat trivial)
application. It uses <code>BrokerFactory()</code> on the server side, and
<code>pb.getObjectAt()</code> on the client side.</p>

<a href="../examples/pbsimple.py" class="py-listing">pbsimple.py</a>
<a href="../examples/pbsimpleclient.py" class="py-listing">pbsimpleclient.py</a>

<p>First we look at the server. This defines an Echoer class (derived from
<code class="API" base="twisted.spread">pb.Root</code>), with a method called
<code>remote_echo()</code>. 
<code class="API" base="twisted.spread">pb.Root</code> objects (because of
their inheritance of 
<code class="API" base="twisted.spread">pb.Referenceable</code>, described
later) can define methods with names of the form <code>remote_*</code>; a
client which obtains a remote reference to that 
<code class="API" base="twisted.spread">pb.Root</code> object will be able to
invoke those methods.</p>

<p>The <code class="API" base="twisted.spread">pb.Root</code>-ish object is
given to a 
<code class="API" base="twisted.spread">pb.BrokerFactory</code><code>()</code>.
This is a <code class="API" base="twisted.internet.protocol">Factory</code>
object like any other: the 
<code class="API" base="twisted.internet.protocol">Protocol</code> objects it
creates for new connections know how to speak the PB protocol. The object you
give to <code>pb.BrokerFactory()</code> becomes the <q>root object</q>, which
simply makes it available for the client to retrieve. The client may only
request references to the objects you want to provide it: this helps you
implement your security model. Because it is so common to export just a single
object (and because a <code>remote_*</code> method on that one can return a
reference to any other object you might want to give out), the simplest example
is one where the <code class="API" base="twisted.spread">BrokerFactory</code>
is given the root object, and the client retrieves it.</p>

<p>The client side calls 
<code class="API" base="twisted.spread">pb.getObjectAt</code> to make a
connection to a given port. This is a convenience function (not a method) which
runs through the PB protocol steps necessary to retrieve the root object from a
<code class="API" base="twisted.spread.pb">BrokerFactory</code> sitting at the
given port.</p>

<p>Because <code>.getObjectAt()</code> has to make a network connection and
exchange some data, it may take a while, so it returns a Deferred, to which the
gotObject() callback is attached. (See the documentation on <a
href="defer.html">Deferring Execution</a> for a complete explanation of
<code class="API" base="twisted.internet.defer">Deferred</code>s). If and when
the connection succeeds and a reference to the remote root object is obtained,
this callback is run. The first argument passed to the callback is a remote
reference to the distant root object.  (you can give other arguments to the
callback too, see the other parameters for <code>.addCallback()</code> and
<code>.addCallbacks()</code>).</p>

<p>The callback does:</p>

<pre class="python">
object.callRemote("echo", "hello network")
</pre>

<p>which causes the server's <code>.remote_echo()</code> method to be invoked.
(running <code>.callRemote("boom")</code> would cause
<code>.remote_boom()</code> to be run, etc). Again because of the delay
involved, <code>callRemote()</code> returns a 
<code class="API" base="twisted.internet.defer">Deferred</code>. Assuming the
remote method was run without causing an exception (including an attempt to
invoke an unknown method), the callback attached to that
<code class="API" base="twisted.internet.defer">Deferred</code> will be
invoked with any objects that were returned by the remote method call.</p>

<p>In this example, the server's <code>Echoer</code> object has a method
invoked, <em>exactly</em> as if some code on the server side had done:</p>

<pre class="python">
echoer_object.remote_echo("hello network")
</pre>

<p>and from the definition of <code>remote_echo()</code> we see that this just
returns the same string it was given: <q>hello network</q>.</p>

<p>From the client's point of view, the remote call gets another 
<code class="API" base="twisted.internet.defer">Deferred</code> object
instead of that string. <code>callRemote()</code> <em>always</em> returns a
<code class="API" base="twisted.internet.defer">Deferred</code>. This is why PB
is described as a system for <q>translucent</q> remote method calls instead of
<q>transparent</q> ones: you cannot pretend that the remote object is really
local.
Trying to do so (as some other RPC mechanisms do, coughCORBAcough) breaks down
when faced with the asynchronous nature of the network. Using Deferreds turns
out to be a very clean way to deal with the whole thing.</p>

<p>The remote reference object (the one given to <code>getObjectAt()</code>'s
success callback) is an instance the 
<code class="API" base="twisted.spread.pb">RemoteReference</code> class. This
means you can use it to invoke methods on the remote object that it refers to.
Only instances of 
<code class="API" base="twisted.spread.pb">RemoteReference</code> eligible for
<code>.callRemote()</code>. The
<code class="API" base="twisted.spread.pb">RemoteReference</code> object is the
one that lives on the remote side (the client, in this case), not the local
side (where the actual object is defined).</p>

<p>In our example, the local object is that <code>Echoer()</code> instance,
which inherits from <code class="API" base="twisted.spread">pb.Root</code>,
which inherits from 
<code class="API" base="twisted.spread">pb.Referenceable</code>. It is that
<code>Referenceable</code> class that makes the object eligible to be available
for remote method calls<span class="footnote">There are a few other classes
that can bestow this ability, but pb.Referenceable is the easiest to
understand; see 'flavors' below for details on the others.</span>. If you have
an object that is Referenceable, then any client that manages to get a
reference to it can invoke any <code>remote_*</code> methods they please.</p>

<div class="note">
<p>The <em>only</em> thing they can do is invoke those
methods.  In particular, they cannot access attributes. From a security point
of view, you control what they can do by limiting what the
<code>remote_*</code> methods can do.</p>

<p>Also note: the other classes like 
<code class="API" base="twisted.spread.pb">Referenceable</code> allow access to
other methods, in particular <code>perspective_*</code> and <code>view_*</code>
may be accessed.  Don't write local-only methods with these names, because then
remote callers will be able to do more than you intended.</p>

<p>Also also note: the other classes like 
<code class="API" base="twisted.spread">pb.Copyable</code> <em>do</em> allow
access to attributes, but you control which ones they can see.</p>
</div>

<p>You don't have to be a 
<code class="API" base="twisted.spread">pb.Root</code> to be remotely callable,
but you do have to be 
<code class="API" base="twisted.spread">pb.Referenceable</code>.  (Objects that
inherit from <code class="API" base="twisted.spread">pb.Referenceable</code>
but not from <code class="API" base="twisted.spread">pb.Root</code> can be
remotely called, but only 
<code class="API" base="twisted.spread">pb.Root</code>-ish objects can be given
to the <code class="API" base="twisted.spread.pb">BrokerFactory</code>.)</p>


<a name="pb/more_refs"><h3>Passing more references</h3></a>

<p>Here is an example of using 
<code class="API" base="twisted.spread">pb.Referenceable</code> in a second
class. The second <code class="API" base="twisted.spread">Referenceable</code>
object can have remote methods invoked too, just like the first. In this
example, the initial root object has a method that returns a reference to the
second object.</p>


<a href="listings/pb/pb1server.py" class="py-listing">pb1server.py</a>
<a href="listings/pb/pb1client.py" class="py-listing">pb1client.py</a>

<p>The root object has a method called <code>remote_getTwo</code>, which
returns the <code>Two()</code> instance. On the client end, the callback gets a
<code class="API" base="twisted.spread.pb">RemoteReference</code> to that
instance. The client can then invoke two's <code>.remote_three()</code>
method.</p>

<p>You can use this technique to provide access to arbitrary sets of objects.
Just remember that any object that might get passed <q>over the wire</q> must
inherit from <code class="API" base="twisted.spread.pb">Referenceable</code>
(or one of the other flavors). If you try to pass a non-Referenceable object
(say, by returning one from a <code>remote_*</code> method), you'll get an
<code class="API" base="twisted.spread.jelly">InsecureJelly</code>
exception<span class="footnote">This can be overridden, by subclassing one of
the Serializable flavors and defining custom serialization code for your class.
See XXX for details.</span>.</p>


<a name="pb/refs_come_back"><h3>References can come back to you</h3></a>

<p>If your server gives a reference to a client, and then that client gives
the reference back to the server, the server will wind up with the same
object it gave out originally. The serialization layer watches for returning
reference identifiers and turns them into actual objects. You need to stay
aware of where the object lives: if it is on your side, you do actual method
calls. If it is on the other side, you do 
<code>.callRemote()</code><span class="footnote">The binary nature of this
local vs. remote scheme works because you cannot give RemoteReferences to a
third party. If you could, then your object A could go to B, B could give it to
C, C might give it back to you, and you would be hard pressed to tell if the
object lived in C's memory space, in B's, or if it was really your own object,
tarnished and sullied after being handed down like a really ugly picture that
your great aunt owned and which nobody wants but which nobody can bear to throw
out. Ok, not really like that, but you get the idea.</span>.</p>

<a href="listings/pb/pb2server.py" class="py-listing">pb2server.py</a>
<a href="listings/pb/pb2client.py" class="py-listing">pb2client.py</a>

<p>The server gives a <code>Two()</code> instance to the client, who then
returns the reference back to the server. The server compares the <q>two</q>
given with the <q>two</q> received and shows that they are the same, and that
both are real objects instead of remote references.</p>

<p>A few other techniques are demonstrated in <code>pb3client.py</code>. One is
that the callbacks are are added with <code>.addCallback</code> instead of
<code>.addCallbacks</code>. As you can tell from the <a
href="defer.html">Deferred</a> documentation, <code>.addCallback</code> is a
simplified form which only adds a success callback. The other is that to
keep track of state from one callback to the next (the remote reference to
the main One() object), we create a simple class, store the reference in an
instance thereof, and point the callbacks at a sequence of bound methods.
This is a convenient way to encapsulate a state machine. Each response kicks
off the next method, and any data that needs to be carried from one state to
the next can simply be saved as an attribute of the object.</p>

<p>Remember that the client can give you back any remote reference you've
given them. Don't base your zillion-dollar stock-trading clearinghouse
server on the idea that you trust the client to give you back the right
reference. The security model inherent in PB means that they can <em>only</em>
give you back a reference that you've given them for the current connection
(not one you've given to someone else instead, nor one you gave them last
time before the TCP session went down, nor one you haven't yet given to the
client), but just like with URLs and HTTP cookies, the particular reference
they give you is entirely under their control.</p>


<a name="pb/twoway_refs"><h3>References to client-side objects</h3></a>

<p>Anything that's Referenceable can get passed across the wire, <em>in either
direction</em>. The <q>client</q> can give a reference to the
<q>server</q>, and then the server can use .callRemote() to invoke methods on
the client end.  This fuzzes the distinction between <q>client</q> and
<q>server</q>: the only real difference is who initiates the original TCP
connection; after that it's all symmetric.</p>

<a href="listings/pb/pb3server.py" class="py-listing">pb3server.py</a>
<a href="listings/pb/pb3client.py" class="py-listing">pb3client.py</a>

<p>In this example, the client gives a reference to its own object to the
server. The server then invokes a remote method on the client-side
object.</p>


<a name="pb/beyond_root"><h3>Beyond a single <q>root object</q>: getting
objects by name</h3></a>

<div class="note"><p>This section looks into the code in a way that might help
you solidify your understanding of what's going on under the hood, or it might
just serve to confuse you horribly. The example described is certainly
<em>not</em> the recommended way to accomplish its goal: it depends upon
internal interfaces that aren't likely to remain stable, and there are far
better ways of doing the same thing. No one will think badly of you if you <a
href="#pb/flavors">skip it</a> until later. But I found it to be a useful
exercise.</p></div>

<p>Before delving into authentication and 
<code class="API">twisted.cred</code>, it may be useful to look more deeply
into the basic PB calls by adding a second object to our server. In practical
applications this isn't very useful: it makes more sense to have your root
object export a method that can be used to get access to as many other objects
as you like. But sometimes doing it the hard way is useful to learn how the
code works, and to gain appreciation for the easy way.</p>

<p>On the server side, we want to wind up with an object that acts like
<code class="API" base="twisted.spread">pb.BrokerFactory</code>, but which can
take extra objects beyond the normal <q>root</q> one. On the client side, we
want to add an extra argument to the <code>getObjectAt()</code> call, to
indicate which of these objects we want to retrieve.  As you might guess, this
involves subclassing 
<code class="API" base="twisted.spread">pb.BrokerFactory</code>, and writing a
new version of 
<code class="API" base="twisted.spread.pb.BrokerFactory">getObjectAt</code>.</p>

<p>How do <code class="API" base="twisted.spread">pb.Broker</code> and 
<code class="API" base="twisted.spread">pb.BrokerFactory</code> work? Well, 
<code class="API" base="twisted.spread">pb.Broker</code> objects
(which are <code class="API" base="twisted.internet.protocol">Protocol</code>s,
so they are created by a 
<code class="API" base="twisted.internet.protocol">Factory</code> when a new
connection is accepted) have a dict that maps object names to the objects
themselves.  The objects are registered with 
<code class="API" base="twisted.spread">pb.Broker</code>'s 
<code class="API" base="twisted.spread.pb.Broker">.setNameForLocal</code>
method, which accepts a name and the corresponding object.</p>

<p><code class="API" base="twisted.spread">pb.BrokerFactory</code> objects have
an attribute named <code>.objectToBroker</code>. When the connection is
accepted and the factory is asked to do <code>.buildProtocol</code>, it
creates the <code>Broker()</code>, does some setup, and then binds <q>root</q>
to its <code>.objectToBroker</code> object by calling
<code>.setNameForLocal()</code> in the new broker.</p>

<div class="note">
<p>Actually, it gives the <code>.objectToBroker</code> a chance to substitute a
different object in its place, by calling the <code>.rootObject()</code>
method:</p>

<pre class="python">
    proto.setNameForLocal("root", self.objectToBroker.rootObject(proto))
</pre>

<p>However, the default behavior of <code>Root.rootObject()</code> is to simply
<q>return self</q>.</p>

<p>This hook exists so that subclasses of 
<code class="API" base="twisted.spread.pb">Root</code> can return different
objects depending upon something in the 
<code class="API" base="twisted.spread.pb">Broker</code> (which is a 
<code class="API" base="twisted.internet.protocol">Protocol</code>) being used.
Since there is one Broker per connection, and the connection source address is
stored in it, the Root-ish object could give out different objects depending
upon which address is connecting.</p>

<p><code class="API" base="twisted.spread">pb.AuthRoot</code> (subclassed from
pb.Root) uses this to return an 
<code class="API" base="twisted.spread.pb">AuthServ</code> object, which starts
the challenge-response authentication sequence described in detail in the
section on pb.cred.</p>
</div>


<p>So, we need a 
<code class="API" base="twisted.spread.pb">BrokerFactory</code> that will do
multiple <code>.setNameForLocal()</code>s on the 
<code class="API" base="twisted.spread.pb">Broker</code>s that it creates. In
the example, we subclass 
<code class="API" base="twisted.spread.pb">BrokerFactory</code> to take an
extra dictionary of names and objects that should be put into the resulting
<code class="API" base="twisted.spread.pb">Broker</code>.</p>

<a href="listings/pb/pb4server.py" class="py-listing">pb4server.py</a>

<p>Now, what about the client? To make this work, we have to look into the
implementation of the convenience function 
<code class="API" base="twisted.spread.pb">getObjectAt</code>. As you learned
in the <a href="clients.html">Writing Clients</a>, clients
are built out of 
<code class="API" base="twisted.internet.protocol">Protocol</code>s just like
servers are, but those 
<code class="API" base="twisted.internet.protocol">Protocol</code>s are created
with <code class="API" base="twisted.internet.protocol">ClientFactory</code> objects instead of normal 
<code class="API" base="twisted.internet.protocol">Factory</code> objects. The
<code class="API" base="twisted.internet.protocol">Protocol</code>that
implements the client side of a PB connection is the same 
<code class="API" base="twisted.spread.pb">Broker</code>class as used on the
server side, but it gets an extra flag to indicate it is a client.  Let's look
at the code behind <code class="API" base="twisted.spread.pb">getObjectAt</code>
(stripped down to ignore the UNIX-domain socket case, and inlining the
<code>getObjectRetriever</code> utility function):</p>

<pre class="python">
def getObjectAt(host, port, timeout=None):
  d = defer.Deferred()
  b = Broker(1)
  bf = BrokerClientFactory(b)
  _ObjectRetrieval(b, d)
  reactor.connectTCP(host, port, bf, timeout)
  return d
</pre>

<p><code>_ObjectRetrieval</code> is a small utility class which sets up a
number of callbacks. We only care about what happens when the connection is
established:</p>

<pre class="python">
class _ObjectRetrieval:
  ...
  def connectionMade(self):
    x = self.broker.remoteForName("root")
    del self.broker
    self.term = 1
    self.deferred.callback(x)
</pre>

<p>When the connection is established, the Broker object is asked to
retrieve the remote object indexed by the name <q>root</q>. Once this is
retrieved, the callback is run, passing the remote object reference as an
argument. That callback is the one hooked to the 
<code class="API" base="twisted.internet.defer">Deferred</code> that was passed
back from <code>getObjectAt()</code>.</p>

<p>So, to get something other than <q>root</q>, we're going to need to replace
<code>getObjectAt()</code> with a version that will take an object name, and
then have it use a subclass of <code>_ObjectRetrieval</code> which can request
that new name. These two functions use some internal symbols, so our versions
will have to import more than a simple user of the normal behavior would
need.</p>

<a href="listings/pb/pb4client.py" class="py-listing">pb4client.py</a>

<p>Run <code>pb4server.py</code>, then run <code>pb4client.py</code> from a
different shell. Note that the different objects get the right arguments. Also
note that they probably aren't run in the same order as the
<code>getSomeObjectAt()</code> functions were executed. Welcome to the
network.</p>


<a name="pb/flavors"><h3>Flavors of remotely-accessible objects: Referenceable
and siblings</h3></a>

<p>This is explained better in the other <a href="pb.html">Perspective
Broker</a> document, in the section entitled <em>Things you can Call
Remotely</em></p>

<p><code>twisted/spread/flavors.py</code> defines an abstract base class called
Serializable. There are four subclasses of 
<code class="API" base="twisted.spread.flavours">Serializeable</code> defined
there: <code class="API" base="twisted.spread.pb">Referenceable</code>, 
<code class="API" base="twisted.spread.pb">Viewable</code>, 
<code class="API" base="twisted.spread.pb">Copyable</code>, and 
<code class="API" base="twisted.spread.pb">RemoteCache</code>. These styles are
imported into <code>twisted/spread/pb.py</code>, and are usually accessed as
<code class="API" base="twisted.spread">pb.Referenceable</code>, etc. For a
given class to be remotely referenceable (i.e.  to allow references to it to
get passed across the wire), that class must inherit from one of these styles.
Basic types (numbers, dictionaries, etc) are always serializable, but classes
must declare which style they want by subclassing one.</p>

<p>The style of serialization defined by those four classes influences how
references to the objects get transferred over the wire.</p>

<ul>

  <li><code class="API" base="twisted.spread">pb.Referenceable</code> is the
  most straightforward. It does not provide any access to the data attributes
  of the object, but allows <code>.callRemote()</code> to be used to invoke any
  <code>remote_*</code> methods that exist. When one of these is sent over the
  wire, it is simply serialized with an identifier that can be returned in the
  <code>.callRemote()</code> request.</li>

  <li><code class="API" base="twisted.spread">pb.Viewable</code> is much like
  <code class="API" base="twisted.spread">pb.Referenceable</code>, but instead
  of exporting <code>remote_*</code> methods, objects derived from this class
  export <code>view_*</code> methods. These methods are invoked with an extra
  first argument that contains the <code>Perspective</code> which provided the
  reference to the original 
  <code class="API" base="twisted.spread">pb.Viewable</code> object.

  <div class="note"><p>When a <code>perspective_*</code> method returns a
  <code class="API" base="twisted.spread">pb.Viewable</code> object, an
  intermediate object called a 
  <code class="API" base="twisted.spread.flavors">ViewPoint</code> is created,
  and the client gets a 
  <code class="API" base="twisted.spread.pb">RemoteReference</code> to that
  <code class="API" base="twisted.spread.flavors">ViewPoint</code>instead. The
  <code class="API" base="twisted.spread.flavors">ViewPoint</code>remembers
  which Perspective it came from. Running <code>.callRemote()</code> on the
  reference of the 
  <code class="API" base="twisted.spread.flavors">ViewPoint</code>results in a
  <code>view_*</code> method being invoked on the 
  <code class="API" base="twisted.spread">pb.Viewable</code> object.</p></div>
 
  <div class="note"><p>It is possible to have both <code>perspective_*</code>
  methods and <code>view_*</code> methods in the same class. See the docstring
  for <code class="API" base="twisted">spread.flavors.ViewPoint</code> for
  details.</p></div>

  </li>


  <p>This is useful to let the object know which client is calling the
  method. This will make more sense after you've read through the pb.cred
  section below.</p>

  <li><code class="API" base="twisted.spread">pb.Copyable</code>: references to
  <code class="API" base="twisted.spread">pb.Copyable</code>-derived objects
  are transferred over the wire by copying them wholesale. The default behavior
  (which can of course be overridden) is to send the name of the object's class
  as a string, and a dict with all the attribute. The receiving end must have a
  class that derives from 
  <code class="API" base="twisted.spread">pb.RemoteCopy</code>, that is
  registered to be created when the named class is sent over the wire. Be
  careful with the implementation of this class, as the server has control of
  what data is used in creating those objects, and you must make sure the
  server cannot trick the client into doing something naughty with that
  data.</li>

  <li><code class="API" base="twisted.spread">pb.Cacheable</code>: this is
  derived from <code class="API" base="twisted.spread">pb.Copyable</code>, and
  attempts to make sure the data is only copied once. There is also code in
  place to notify the client when the state of the object changes. 
  <code>flavors.py</code> says this is the most complex and least-documented
  part of PB. Good luck.</li>
  
</ul>


<p>So those are the four kinds of remotely-referenceable objects. There are
also multiple kinds of remote method calls, somewhat loosely linked to those
four classes (now known as the Serializer Siblings) (except they're all
subclasses of Serializer) (and Serializer Subclasses sounds so stupid).
Ahem. The differences between the remote method calls depends upon what your
<code class="API" base="twisted.spread.pb">RemoteReference</code> is actually
pointing to on the other side.</p>

<p>If it is pointing to a simple 
<code class="API" base="twisted.spread">pb.Referenceable</code>, then your 
<code>.callRemote("foo")</code> gets turned into a <code>.remote_foo()</code>
on the other end.</p>

<p>If it points at a Perspective (described below), then 
<code>.callRemote("foo")</code> invokes <code>.perspective_foo()</code> on that
object.</p>

<p>If your Perspective named <code>perspective1</code> returns a reference to a
<code class="API" base="twisted.spread">pb.Viewable</code> named 
<code>thing1</code>, then <code>.callRemote("foo", arg1)</code> on the
resulting <code class="API" base="twisted.spread.pb">RemoteReference</code>
causes <code>thing1.view_foo(perspective1, arg1)</code> to be invoked.  This
lets <code>thing1</code> tell the difference between <code>perspective1</code>
doing <code>.view_foo()</code> and some other perspective doing the same
method.  <code class="API" base="twisted.spread">pb.Referenceable</code>
subclasses have no way to find out who is invoking their methods, but
<code class="API" base="twisted.spread">pb.Viewable</code> derivatives can.</p>

<p>Again, Perspectives will make much more sense after the next chapter. My
advice is to pronouce Perspective as <em>u-s-e-r</em> until you've read that
part.</p>


<a name="pb/exceptions"><h3>Returning Exceptions</h3></a>

<p>Everything so far has covered what happens when things go right. What
about when they go wrong? The Python Way is to raise an exception of some
sort. The Twisted Way is the same.</p>

<p>The only special thing you do is to define your <code>Exception</code>
subclass by deriving it from 
<code class="API" base="twisted.spread">pb.Error</code>.  (You do define
<code>Exception</code> subclasses, right? String exceptions are, like,
<em>so</em> 5 minutes ago. Get with the new century, ok?). When any
remotely-invokable method (like <code>remote_*</code> or
<code>perspective_*</code>) raises a <code>pb.Error</code>-derived exception, a
serialized form of that Exception object will be sent back over the 
wire<span class="footnote">To be precise, the Failure will be sent if
<em>any</em> exception is raised, not just pb.Error-derived ones.
But the server will print ugly error messages if you raise ones that aren't
derived from pb.Error.</span>. The other side (which did
<code>callRemote</code>) will have the <q><code>errback</code></q> callback run
with a <code class="API" base="twisted.python.failure">Failure</code> object
that contains a copy of the exception object. This <code>Failure</code> object
can be queried to retrieve the error message and a stack traceback.</p>

<p><code class="API" base="twisted.python.failure">Failure</code> is a
special class, defined in <code>twisted/python/failure.py</code>, created to
make it easier to handle asynchronous exceptions. Just as exception handlers
can be nested, <code>errback</code> functions can be chained. If one errback
can't handle the particular type of failure, it can be <q>passed along</q> to a
errback handler further down the chain.</p>

<p>For simple purposes, think of the <code>Failure</code> as just a container
for remotely-thrown <code>Exception</code> objects. To extract the string that
was put into the exception, use its <code>.getErrorMessage()</code> method.
To get the type of the exception (as a string), look at its
<code>.type</code> attribute. The stack traceback is available too. The
intent is to let the errback function get just as much information about the
exception as Python's normal <code>try:</code> clauses do, even though the
exception occurred in somebody else's memory space at some unknown time in
the past.</p>

<p>To implement the equivalent of the Python try/except blocks (which can
trap particular kinds of exceptions and pass others <q>up</q> to higher-level
try/except blocks), you can use the <code>.trap()</code> method in
conjunction with multiple <code>errback</code> handlers on the
<code>Deferred</code>. Raising an exception in an <code>errback</code> handler
serves to pass that new exception to the next handler in the chain. Check
the <code>Failure.trap</code> docstring for details. XXX: add a working example
of this.</p>

<a href="listings/pb/exc_server.py" class="py-listing">exc_server.py</a>
<a href="listings/pb/exc_client.py" class="py-listing">exc_client.py</a>

<pre class="shell">
% ./exc_client.py 
got remote Exception
 .__class__ = twisted.spread.pb.CopiedFailure
 .getErrorMessage() = fall down go boom
 .type = __main__.MyError
Main loop terminated.
</pre>

<p>Oh, and what happens if you raise some other kind of exception? Something
that <em>isn't</em> subclassed from <code>pb.Error</code>? Well, those are
called <q>unexpected exceptions</q>, which make Twisted think that something
has <em>really</em> gone wrong. These will raise an exception on the
<em>server</em> side. This won't break the connection (XXX: verify this), but
it will print out an unsightly stack trace on the server's stderr (XXX: if
logging is turned on, does it go into the log instead?), just as if the
exception had happened outside a remotely-invokable method. The client will get
the same <code>Failure</code> object in either case, but subclassing your
exception from <code>pb.Error</code> is the way to tell Twisted that you expect
this sort of exception, and that it is ok to just let the client handle it.
Look at <code>exc_client.py</code> and change it to invoke
<code>broken2()</code> instead of <code>broken()</code> to see the change in
the server's behavior.</p>

<p>If you don't add an <code>errback</code> function to the <code class="API"
base="twisted.internet.defer">Deferred</code>, then a remote exception will
still send a <code>Failure</code> object back over, but the side that did
<code>callRemote</code> will emit a message about an <q>Unhandled error in
Deferred</q>, along with an ugly stack trace. It can't raise an exception
(after all, the <code>callRemote</code> that triggered the problem is long
gone), but it will emit a traceback. So be a good programmer and <em>always add
<code>errback</code> handlers</em>.</p>


<a name="pb/LAST_SF_EXIT"><h2>Wrapup before touching twisted.cred</h2></a>

<p>So now you've got all of PB at your feet (except the P part, that's
waiting for the next chapter). Once you architect your system around the
idea of objects in different processes invoking methods on each other, then
it's a simple matter of writing the right 
<code class="API" base="twisted.spread">pb.Referenceable</code> and 
<code class="API" base="twisted.spread">pb.Root</code> classes, adding
<code>remote_*</code> methods to them, and starting the clients with
<code>.getObjectAt()</code>. Remember that <code>.callRemote()</code> always
returns a <code class="API" base="twisted.internet.defer">Deferred</code>, so
think asynchronously: state machines are common, as are series of chained
callbacks to implement multi-step RPC sequences one step at a time.</p>

<p>It would be a good idea to pause now and write some code to get the feel
for PB (but for the sake of the exercise, stay away from the 
<code class="API" base="twisted.spread">pb.Perspective</code> class: stick to
<code class="API" base="twisted.spread">pb.Root</code> and 
<code class="API" base="twisted.spread">pb.Referenceable</code>).  Try writing
a small chat server: The server is the initial 
<code class="API" base="twisted.spread">pb.Root</code> object, each user gets
their own object, each group has its own object, the Users have a list of
Groups they belong to, the Groups have a list of Users who have joined them.
Users can send a message to a Group; the Group then sends the message out to
all their Users. The client side can probably be implemented with a single
<code>remote_showText()</code> method, invokable by the Groups on the other
end. For this exercise, ignore security completely. When the User first
connects, let them tell you what their name is, and give them a reference to
their User object based upon that name.</p>

<p>The two reasons for writing this code now, before you go on to the next
section: one: it will solidify your understanding of basic PB remote method
calls without adding in the confusion of authentication yet, and two: you
will probably encounter some common problems that will help you understand
<em>why</em> <code class="API">twisted.cred</code> provides the facilities that
it does.</p>

<p>Implementing a chat server is a doubly useful exercise, because 
<code class="API">twisted.words</code> provides a very similar service. When
you've finished with the next section on <code class="API">twisted.cred</code>,
you'll see how the differences between your code and the implementation in
<code class="API">twisted.words</code> is mainly in the authorization and
user/perspective areas. (well, if you ignore the web interface, the IRC
interface, and all the hooks for running bots of various kinds).</p>

<p>That's the end of the tour. If you have any questions, the folks at the
welcome office will be more than happy to help. Don't forget to stop at the
gift store on your way out, and have a really nice day. Buh-bye now!</p>

<p>And be sure to check out <a href="pb-cred.html">Part Two</a>, where we
delve into users and 
<code class="API" base="twisted.cred.perspective">Perspective</code>s and 
<code class="API" base="twisted.cred.identity">Identity</code>s (and bears! Oh,
my.)</p>

</body> </html>
