<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Using Processes</title>
  </head>
  
  <body>
    <h1>Using Processes</h1>
    
    <h2>Overview</h2>

<p>Along with connection to servers across the internet, Twisted also
connects to local processes with much the same API. The API is described in
more detail in the documentation of:
<ul>
<li><code class="API">twisted.internet.interfaces.IReactorProcess</code></li>
<li><code class="API">twisted.internet.interfaces.IProcessTransport</code></li>
<li><code class="API">twisted.internet.protocol.ProcessProtocol</code></li>
</ul>
</p>

    <h2>Running Another Process</h2>

<p>Processes are run through the reactor, using <code
class="python">reactor.spawnProcess()</code>. Pipes are created to the child
process, and added to the reactor core so that the application will not
block while sending data into or pulling data out of the new process. <code
class="python">reactor.spawnProcess()</code> requires two arguments,
processProtocol and executable, and optionally takes six more: arguments,
environment, path, userID, groupID, and usePTY.</p>


<pre class="python">
from twisted.internet import reactor

mypp = MyProcessProtocol()
reactor.spawnProcess(processProtocol, executable, args=[program, arg1, arg2],
                     env={'HOME': os.environ['HOME']}, path,
                     uid, gid, usePTY)
</pre>

<ul>

  <li><code>processProtocol</code> should be an instance of a subclass of <code
  class="API">twisted.internet.protocol.ProcessProtocol</code>. The
  interface is described below.</li>

  <li><code>executable</code> is the full path of the program to run. It will be
  connected to processProtocol.</li>

  <li><code>args</code> is a list of command line arguments to be passed to the
  process. <code>args[0]</code> should be the name of the process.</li>

  <li><code>env</code> is a dictionary containing the environment to pass
  through to the process.</li>

  <li><code>path</code> is the directory to run the process in. The child will
  switch to the given directory just before starting the new program. The
  default is to stay in the current directory.</li>

  <li><code>uid</code> and <code>gid</code> are the user ID and group ID to run the
  subprocess as. Of course, changing identities will be more likely to
  succeed if you start as root.</li>

  <li><code>usePTY</code> specifies whether the child process should be run with
  a pty, or if it should just get a pair of pipes. Interactive programs
  (where you don't know when it may read or write) need to be run with
  ptys.</li>

</ul>

<p><code>args</code> and <code>env</code> have empty default values, but many
programs depend upon them to be set correctly. At the very least,
<code>args[0]</code> should probably be the same as <code>executable</code>. If you
just provide <code>os.environ</code> for <code>env</code>, the child program will
inherit the environment from the current process, which is usually the
civilized thing to do (unless you want to explicitly clean the environment
as a security precaution). </p>
  
<p><code class="python">reactor.spawnProcess()</code> returns an instance
that implements the <code
class="API">twisted.internet.interfaces.IProcessTransport</code>.</p>

  <h2>Writing a ProcessProtocol</h2>
    <p>The ProcessProtocol you pass to spawnProcess is your interaction with the process.  It has a very similar signature to a regular Protocol, but it has several extra methods to deal with events specific to a process.  In our example, we will interface with 'wc' to create a word count of user-given text.  First, we'll start by importing the required modules, and writing the initialization for our ProcessProtocol.</p>
<pre class="python">
from twisted.internet import protocol
class WCProcessProtocol(protocol.ProcessProtocol):

    def __init__(self, text):
        self.text = text
</pre>

    <p>When the ProcessProtocol is connected to the protocol, it has the connectionMade method called.  In our protocol, we will write our text to the standard input of our process and then close standard input, to the let the process know we are done writing to it.</p>
<pre class="python">
    def connectionMade(self):
        self.transport.write(self.text)
        self.transport.closeStdin()
</pre>

    <p>At this point, the process has receieved the data, and it's time for us to read the results.  Instead of being receieved in dataReceived, data from standard output is receieve in outReceived.  This is to distinguish it from data on standard error.</p>
<pre class="python">
    def outReceived(self, data):
        fieldLength = len(data) / 3
        lines = int(data[:fieldLength])
        words = int(data[fieldLength:fieldLength*2])
        chars = int(data[fieldLength*2:])
        self.transport.loseConnection()
        self.receiveCounts(lines, words, chars)
</pre>

    <p>Now, the process has parsed the output, and ended the connection to the process.  Then it sends the results on to the final method, receiveCounts.  This is for users of the class to override, so as to do other things with the data.  For our demonstration, we will just print the results.</p>
<pre class="python">
    def receiveCounts(self, lines, words, chars):
        print 'Received counts from wc.'
        print 'Lines:', lines
        print 'Words:', words
        print 'Characters:', chars
</pre>

    <p>We're done!  To use our WCProcessProtocol, we create an instance, and pass it to spawnProcess.</p>
<pre class="python">
from twisted.internet import reactor
wcProcess = WCProcessProtocol("accessing protocols through Twisted is fun!\n")
reactor.spawnProcess(wcProcess, 'wc', ['wc'])
reactor.run()
</pre>


<h2>Things that can happen to your ProcessProtocol</h2>

<p>These are the methods that you can usefully override in your subclass of
<code>ProcessProtocol</code>:</p>

<ul>

  <li><code>.connectionMade</code>: This is called when the program is started,
  and makes a good place to write data into the stdin pipe (using <code
  class="python">self.transport.write()</code>).</li>

  <li><code>.outReceived(data)</code>: This is called with data that was
  received from the process' stdout pipe. Pipes tend to provide data in
  larger chunks than sockets (one kilobyte is a common buffer size), so you
  may not experience the "random dribs and drabs" behavior typical of
  network sockets, but regardless you should be prepared to deal if you
  don't get all your data in a single call. To do it properly,
  <code>outReceived</code> ought to simply accumulate the data and put off doing
  anything with it until the process has finished.</li>

  <li><code>.errReceived(data)</code>: This is called with data from the
  process' stderr pipe. It behaves just like <code>outReceived</code>.</li>

  <li><code>.inConnectionLost</code>: This is called when the reactor notices
  that the process' stdin pipe has closed. Programs don't typically close
  their own stdin, so this will probably get called when your
  ProcessProtocol has shut down the write side with <code
  class="python">self.transport.loseConnection()</code>.</li>

  <li><code>.outConnectionLost</code>: This is called when the program closes
  its stdout pipe. This usually happens when the program terminates.</li>

  <li><code>.errConnectionLost</code>: Same as <code>outConnectionLost</code>, but
  for stderr instead of stdout.</li>

  <li><p><code>.processEnded(status)</code>: This is called when the child
  process has been reaped, and receives information about the process' exit
  status. The status is passed in the form of a <code class="API"
  base="twisted.python.failure">Failure</code> instance, created with a
  <code>.value</code> that either holds a <code class="API"
  base="twisted.internet.error">ProcessDone</code> object if the process
  terminated normally (it died of natural causes instead of receiving a
  signal, and if the exit code was 0), or a <code class="API"
  base="twisted.internet.error">ProcessTerminated</code> object (with an
  <code>.exitCode</code> attribute) if something went wrong. This scheme may
  seem a bit weird, but I trust that it proves useful when dealing with
  exceptions that occur in asynchronous code.</p>

  <!-- XXX: check twisted/internet/process.py:v1.30:line357, I think
  death-by-signal wouldn't be reported properly. -->
  
  <p>This will always be called <b>after</b> <code>inConnectionLost</code>,
  <code>outConnectionLost</code>, and <code>errConnectionLost</code> are
  called.</p></li>

</ul>

<p>The base-class definitions of these functions are all no-ops. This will
result in all stdout and stderr being thrown away. Note that it is important
for data you don't care about to be thrown away: if the pipe were not read,
the child process would eventually block as it tried to write to a full
pipe.</p>


<h2>Things you can do from your ProcessProtocol</h2>

<p>The following are the basic ways to control the child process:</p>

<ul>

  <li><code>self.transport.write(data)</code>: Stuff some data in the stdin
  pipe. Note that this <code>write</code> method will queue any data that can't
  be written immediately. Writing will resume in the future when the pipe
  becomes writable again.</li>

  <li><code>self.transport.closeStdin</code>: Close the stdin pipe. Programs
  which act as filters (reading from stdin, modifying the data, writing to
  stdout) usually take this as a sign that they should finish their job and
  terminate. For these programs, it is important to close stdin when you're
  done with it, otherwise the child process will never quit.</li>

  <li><code>self.transport.closeStdout</code>: Not usually called, since you're
  putting the process into a state where any attempt to write to stdout will
  cause a SIGPIPE error. This isn't a nice thing to do to the poor
  process.</li>
  
  <li><code>self.transport.closeStderr</code>: Not usually called, same reason
  as <code>closeStdout</code>.</li>

  <li><code>self.transport.loseConnection</code>: Close all three pipes.</li>

  <li><code>os.kill(self.transport.pid, signal.SIGKILL)</code>: Kill the child
  process. This will eventually result in <code>processEnded</code> being
  called.</li>
  
</ul>


<h2>Verbose Example</h2>

<p>Here is an example that is rather verbose about exactly when all the
methods are called. It writes a number of lines into the <code>wc</code> program
and then parses the output.</p>

<a href="listings/process/process.py" class="py-listing">process.py</a>

<p>The exact output of this program depends upon the relative timing of some
un-synchronized events. In particular, the program may observe the child
process close its stderr pipe before or after it reads data from the stdout
pipe. One possible transcript would look like this:</p>

<pre class="shell">
% ./process.py 
connectionMade!
inConnectionLost! stdin is closed! (we probably did it)
errConnectionLost! The child closed their stderr.
outReceived! with 24 bytes!
outConnectionLost! The child closed their stdout!
I saw 40 lines
processEnded, status 0
quitting
Main loop terminated.
% 
</pre>

<h2>Doing it the Easy Way</h2>

<p>Frequently, one just need a simple way to get all the output from a
program. For those cases, the 
<code class="api">twisted.internet.utils.getProcessOutput</code>
function can be used. Here is a simple example:</p>

<a href="listings/process/quotes.py" class="py-listing">quotes.py</a>

<p>If you need to get just the final exit code, the 
<code class="api">twisted.internet.utils.getProcessValue</code>
function is useful. Here is an example:</p>

<a href="listings/process/trueandfalse.py" class="py-listing">trueandfalse.py</a>

  </body>
</html>
