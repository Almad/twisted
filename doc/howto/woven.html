<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Developing Componentized Web Applications using Woven, the Web Object Visualization Environment</title>
  </head>

  <body>
    <h1>Developing Componentized Web Applications using Woven, the Web Object Visualization Environment</h1>

<p>
DOMTemplate solves the problem of separating logic from
presentation, and allows the template manipulation logic to be expressed in
Python code form using the DOM API. However, the DOM API is too low
level and it quickly becomes tedious to use to build complicated HTML
structures.
</p>


    <h2>Twisted's Solution</h2>

<p>
Twisted's solution is to provide a Model-View-Controller based
component framework, which allows you to construct complex HTML
<q>Views</q> out of many small interacting components, or 
<code class="API" base="twisted.web">woven.widgets</code>.
</p>

<p>
Instead of manipulating DOM objects which represent low-level HTML
Nodes, you construct and compose the model data that your page will
be based on, and specify views which will be responsible for
formatting the model data as HTML. Using widgets defined in
twisted.web.woven.widgets, and higher-level widgets that you define
yourself for an application-specific purpose, python data structures
such as strings, integers, lists, dicts, and custom subclasses of woven.model.Model, can be adapted implicitly or
explicitly to subclasses of woven.view.View (such as subclasses of
woven.widgets.Widget) for display in HTML.
</p>

    <h3>Model-View-Controller</h3>

<p>
Model View Controller is a development strategy which
involves breaking up program logic into three separate domains:
Model objects, whose job it is to contain data; View objects, whose
job it is to present this data to the user; and Controller objects,
whose job it is to handle events such as <q>user input from a form</q> and
<q>fetch URL</q> and update the model and view with the user's desired changes.
</p>

<p>
Woven's implementation of MVC uses twisted.python.components, 
the interface and component registry,  to loosely couple the interacting objects.
</p>

<h3>Hello World with Page</h3>

<p>Let's start with the canonical Hello World example. We will use an instance of woven.page.Page as our IResource implementor. IResource describes the interface objects are required to implement in order to publish themselves over the web in twisted.web. We will be instanciating a Page instance in an .rpy script. An rpy is like a CGI script -- each time you visit the script, it is executed. However, an rpy script is merely responsible for instanciating a Resource object to handle the request and assigning it to a variable named "resource".
</p>

<pre class="python">
from twisted.web.woven import page

resource = page.Page("Hello, world!", templateFile = "HelloWorld.html")
</pre>

<p>
Next, let's take a look at the HTML template woven will look up to render this request into HTML. Woven defines three special attributes, model=, view=, and controller=, which it uses to decide which python code to invoke while rendering the page. In the template below, we have simply indicated that woven should replace certain nodes with the results of rendering a widget on the current model. The syntax model="." indicates that woven should use the current model no matter what it's name, similar to filesystem syntax. Since we aren't explicitly stating WHICH view widget should render the model with a view= attribute, an IView adapter is looked up from the global registry implicitly.
</p>

<a href="listings/HelloWorld/HelloWorld.html" class="html-listing">Listing 1: HelloWorld.xhtml: Hello World Web Template</a>

<p>
Next, let's look at an example of rendering a page with a more complicated model. First, we need a place to gather all the Model data together so the View has access to it. The base woven.model.Model is a good container to place other models in, and doing so is as simple as calling setSubmodel. Notice that setSubmodel takes a key and a value, the name the submodel will be available as, and the actual submodel data.
</p>

<p>
Woven comes with various widgets which are registered as IView implementors for the basic python types (strings, lists, and dictionaries) which are very useful. Most of the time, you can simply prepare the data for rendering by converting it into strings and lists in a Model subclass, and then referencing these strings and lists in your template. Here is an example of using an rpy to set up some model data:
</p>

<p>
<a href="listings/HelloWorld/HelloWorld2.rpy" class="py-listing">Listing 2: HelloWorld2.rpy: Setting up submodels</a>
</p>

<p>
This time, in our HTML template, we're going to have to be a little more explicit when specifying view widgets to render the model data. It's generally a good idea to always explicitly state the name of the view widget you want to handle a node; but it's convenient that you don't have to, for example if you're rendering a custom model/view pair where it doesn't make sense to use any other view widgets to render a model.
</p>

<p>
<a href="listings/HelloWorld/HelloWorld2.html" class="py-listing">Listing 3: HelloWorld2.html: Explicitly stating view widget names in the template</a>
</p>

<p>
As you can see from the template, the List widget requires specially tagged nodes inside of it's node in order to operate properly. These nodes are called "pattern" nodes, and each widget can choose to require certain patterns, or look for certain optional patterns, during the course of rendering itself. In the list widget's case, it looks for the pattern "listItem" and makes one copy of it for each element in the list it is rendering. There are two ways to specify a patten node; one, by putting a pattern= attribute on a node, and two by putting a patternName + 'Of'="modelName" attribute on a node. This is easier to show by example than to explain; look at the template for an example of the second usage.
</p>

<p>
Look at the documentation for each individual widget to see what patterns a Widget supports. The List widget is particularly useful; it supports the following patterns:
</p>

<ul>
    <li>listItem</li>
    <li>listHeader</li>
    <li>listFooter</li>
    <li>emptyList</li>
</ul>

<p>
Notice a few things about this template. First, we are explicitly stating the view widget we wish to render each node with a view= attribute. All these view widgets are defined in woven/widgets.py, the default woven widgets library. You can also create your own widget libraries for your views, as well as defining subwidget names on more complicated views that are only valid within that views's HTML node.
</p>

<p>
You now know how to create a woven HTML template, and how to populate this template with data in the form of simple python data types. However, often you will wish to render a dynamic data source, such as a database, or a complex data source such as a python object. One way to render this data over the web is to create a class which implements IModel, the interface woven uses to expose data to view widgets.
</p>

<h3>Implementing IModel</h3>

<p>
The IModel interface is documented in twisted.web.woven.interfaces. It describes the interfaces Models must implement in order to play well with the rest of the woven MVC framework. If you are inheriting from twisted.web.woven.model.Model, most of these interfaces will be implemented for you. The interfaces that we will be most interested in implementing are those that are designed to be overridden for customization, getData and setData.
</p>

<p>
Let's create a simple Model which wraps a quoter that was created in a previous HOWTO. The constructor stores the filename and creates a new FortuneQuoter instance.
</p>

<pre>under construction...</pre>

</body>
</html>

