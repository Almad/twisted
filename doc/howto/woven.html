<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Developing Componentized Web Applications using Woven, the Web Object Visualization Environment</title>
  </head>

  <body>
    <h1>Developing Componentized Web Applications using Woven, the Web Object Visualization Environment</h1>


<h2>Introduction</h2>

<p>
DOMTemplate solves the problem of separating logic from
presentation, and allows the template manipulation logic to be expressed in
Python code form using the DOM API. However, the DOM API is too low
level and it quickly becomes tedious to use to build complicated HTML
structures.
</p>

<p>
Twisted's solution is to provide a Model-View-Controller based
component framework, which allows you to construct complex HTML
<q>Views</q> out of many small interacting components, or 
<code class="API" base="twisted.web">woven.widgets</code>.
</p>

<p>
Instead of manipulating DOM objects which represent low-level HTML
Nodes, you construct and compose the model data that your page will
be based on, and specify views which will be responsible for
formatting the model data as HTML. Using widgets defined in
twisted.web.woven.widgets, and higher-level widgets that you define
yourself for an application-specific purpose, python data structures
such as strings, integers, lists, dicts, and custom subclasses of
<code class="API" base="twisted.web">woven.model.Model</code>, can be adapted
implicitly or explicitly to subclasses of 
<code class="API" base="twisted.web">woven.view.View</code> (such as subclasses
of <code class="API" base="twisted.web">woven.widgets.Widget</code>) for
display in HTML.
</p>

<h2>Model-View-Controller</h2>

<p>
Model View Controller is a development strategy which
involves breaking up program logic into three separate domains:
Model objects, whose job it is to contain/produce data; View objects, whose
job it is to present this data to the user; and Controller objects,
whose job it is to handle events such as <q>user input from a form</q> and
<q>fetch URL</q> and update the model with the user's desired changes. When the
controller finishes updating the model, it tells the model to notify all views
that the model has changed so they may rerender themselves accordingly.
</p>

<p>
Woven's implementation of MVC uses 
<code class="API" base="twisted.web">twisted.python.components</code>, 
the interface and component registry, to loosely couple the interacting objects.
</p>

<h2>Hello World with Page</h2>

<p>Let's start with the canonical Hello World example. We will use an instance
of <code class="API" base="twisted.web">woven.page.Page</code> as our 
<code class="API" base="twisted.web.resource">IResource</code> implementor. 
<code class="API" base="twisted.web.resource">IResource</code> describes the
interface that objects are required to implement in order to publish themselves
over the web in twisted.web. We will be instanciating a 
<code class="API" base="twisted.web">Page</code> instance in an .rpy
script. An rpy is like a CGI script -- each time you visit the script, it is
executed. However, an rpy script is merely responsible for instanciating a
<code class="API" base="twisted.web.resource">Resource</code> object to handle
the request and assigning it to a variable named
<q>resource</q>. This 
<code class="API" base="twisted.web.resource">Resource</code> object will then
be called upon to render the request.
</p>

<a href="listings/HelloWorld/HelloWorld.rpy" class="py-listing">Listing 1: HelloWorld.rpy: Hello World Resource Script</a>

<p>
Next, let's take a look at the HTML template woven will look up to render this
request into HTML. Woven defines three special attributes, <code>model=</code>,
<code>view=</code>, and <code>controller=</code>, which it uses to decide which
python code to invoke while rendering the page. 
</p>

<a href="listings/HelloWorld/HelloWorld.html" class="html-listing">Listing 2: HelloWorld.xhtml: Hello World Web Template</a>

<p>
In the template, we have simply indicated that woven should replace certain
nodes with the results of rendering a widget on the current model. The syntax
<code>model="."</code> indicates that woven should use the current model no
matter what its
name, similar to filesystem syntax. Since we aren't explicitly stating
<em>which</em> view widget should render the model with a <code>view=</code>
attribute, an
<code class="API" base="twisted.web.woven.interfaces">IView</code> adapter is
looked up from the global registry implicitly. In this case,
the model is a string, so an instance of 
<code class="API" base="twisted.web.woven">widgets.Text</code> is constructed
which converts the python string into a DOM text node and inserts it into the
DOM.
</p>

<p>
Next, let's look at an example of rendering a page with a more complicated
model. We're going to make several pieces of data available to the template
under different names. We will refer to these pieces of data as
<q>Submodels</q>, since they are contained in a 
<code class="API" base="twisted.web.woven.model">Model</code> instance.
</p>

<p>
<a href="listings/HelloWorld/HelloWorld2.rpy" class="py-listing">Listing 3: HelloWorld2.rpy: Setting up submodels with a resource script</a>
</p>

<p>
We need a place to gather all the Model data together so the View has access to
it. <code class="API" base="twisted.web">woven.model.AttributeModel</code> is a
good container to place other models in,
and to do so we simply call setSubmodel. Notice that setSubmodel takes a key
and a value, the name the submodel will be available as to the template, and
the actual submodel data.
</p>

<p>
Woven comes with various widgets which are registered as 
<code class="API" base="twisted.web.woven.interfaces">IView</code> implementors
for
the basic python types (strings, lists, and dictionaries) which are very
useful. Most of the time, you can simply prepare the data for rendering by
converting it into strings and lists using an rpy or custom Model subclass, and
then referencing these strings and lists in your template.
</p>

<p>
This time, in our HTML template, we're going to have to be a little more
explicit when specifying view widgets to render the model data. It's generally
a good idea to always explicitly state the name of the view widget you want to
handle a node; but it's convenient that you don't have to, for example if
you're rendering a custom model/view pair where it doesn't make sense to use
any other view widgets to render a given model instance.
</p>

<p>
<a href="listings/HelloWorld/HelloWorld2.html" class="html-listing">Listing 4: HelloWorld2.html: Explicitly stating view widget names in the template</a>
</p>

<p>
As you can see from the template, the 
<code class="API" base="twisted.web.woven.widgets">List</code> widget requires
specially tagged
nodes inside of it's node in order to operate properly. These nodes are called
<q>pattern</q> nodes, and each widget can choose to require certain patterns, or
look for certain optional patterns, during the course of rendering itself. In
the list widget's case, it looks for the pattern <q>listItem</q> and makes one
copy of it for each element in the list it is rendering. There are two ways to
specify a patten node: 
<ul>
    <li>By putting a <code>pattern="patternName"</code> attribute on a node</li>
    <li>By putting a <code>patternName + 'Of'="modelName"</code> attribute on a
        node</li>
</ul>
This is easier to show by example than to explain; look at the template for an
example of the second usage.
</p>

<p>
Look at the documentation for each individual widget to see what patterns a
<code class="API" base="twisted.web.woven.widgets">Widget</code> supports. The 
<code class="API" base="twisted.web.woven.widgets">List</code> widget is
particularly useful; it supports the following patterns:
</p>

<ul>
    <li>listItem</li>
    <li>listHeader</li>
    <li>listFooter</li>
    <li>emptyList</li>
</ul>

<p>
Notice a few things about this template. First, we are explicitly stating the
view widget we wish to render each node with a <code>view=</code> attribute.
All these view widgets are defined in <code>woven/widgets.py</code>, the
default woven widgets library. You can also create your own widget libraries
for your views, as well as defining subwidget names on more complicated views
that are only valid within that views's HTML node. Procedures for doing so will
be described in later HOWTOs.
</p>

<p>
You now know how to create a woven HTML template, and how to populate this
template with data in the form of simple python data types. However, often you
will wish to render a dynamic data source, such as a database, or a complex
data source such as a python object. One way to render this data over the web
is to create a class which implements 
<code class="API" base="twisted.web.woven.model">IModel</code>, the interface
woven uses to expose data to view widgets.
</p>

<h2>Implementing IModel</h2>

<p>
The <code class="API" base="twisted.web.woven.model">IModel</code> interface is
documented in <code class="API">twisted.web.woven.interfaces</code>. It
describes the interfaces Models must implement in order to play well with the
rest of the woven MVC framework. If you are inheriting from
<code class="API">twisted.web.woven.model.Model</code>, most of these
interfaces will be implemented for you. The interfaces that we will be most
interested in implementing are those that are designed to be overridden for
customization, 
<code class="API" base="twisted.web.woven.interfaces.IModel">getData</code> and
<code class="API" base="twisted.web.woven.interfaces.IModel">setData</code>.
</p>

<p>
<a href="listings/TwistedQuotes/wovenquotes.py" class="py-listing">Listing 5: wovenquotes.py: Implementing IModel to provide custom Model behavior</a>
</p>

<p>
We have created a simple Model which wraps a quoter that was created in a
previous HOWTO. The constructor stores the filename and creates a new
FortuneQuoter instance.
</p>

<p>
Implementing 
<code class="API" base="twisted.web.woven.interfaces.IModel">getData</code> 
is as simple as delegating to our FortuneQuoter instance.
<code>getQuote</code> returns a string. In the template, we will specify that
the <code class="API" base="twisted.web.woven.widgets">Text</code>
widget should render the data returned by the quote model, so the quote shows
up in the template. But first, we need to get an instance of MQuote into the
model namespace, using an rpy:
</p>

<p>
<a href="listings/TwistedQuotes/wovenquotes.py" class="py-listing">Listing 6: wovenquotes.rpy: Tying together a custom Model subclass and an html template with an rpy</a>
</p>

<p>
This time, instead of using an instance of AttributeModel as our main model
namespace, we have chosen to simply use a dictionary. Since a dictionary
doesn't implement 
<code class="API" base="twisted.web.woven.interfaces">IModel</code>, an
attribute lookup occurs which wraps the dictionary in an instance of 
<code class="API" base="twisted.web.woven.model">DictionaryModel</code>, which
does implement 
<code class="API" base="twisted.web.woven.interfaces">IModel</code>. Then all
of the dictionary keys will be available as submodel names.
</p>

<p>
<a href="listings/TwistedQuotes/WovenQuotes.xhtml" class="html-listing">Listing 7: WovenQuotes.xhtml: WovenQuotes Template</a>
</p>

<p>
Woven templates are designed to minimize the amount of logic contained in the
HTML template. A woven template is a collection of HTML nodes that are tagged
with various strings which woven uses to locate python components that are then
responsible for producing the final output. In this case, we joined the output
of our <code class="API" base="twisted.web.woven.model">Model</code> subclass' 
<code class="API" base="twisted.web.woven.interfaces.IModel">getData</code> (a
string) with the <code class="API" base="twisted.web.woven.widgets">Text</code> 
widget (which knows how to render strings into DOM).
</p>

<p>
The same theory is used for input handling by 
<code class="API" base="twisted.web.woven.controller">Controllers</code>. In
the template, we
have placed the following input node:
</p>

<pre>
&lt;input type="text" name="quote" model="quote" controller="Anything" /&gt;
</pre>

<p>
When woven encounters this node, it will look up the submodel name
<q>quote</q>, and will get an instance of MQuote. It will then look up the
controller name
<q><code>Anything</code></q>. 
<code class="API" base="twisted.web.woven.input">Anything</code> is an 
<code class="API" base="twisted.web.woven.input">InputHandler</code> (a
specialized type of controller
designed to handle web request input) defined in 
<code class="API"> twisted.web.woven.input</code>.
Similarly to <code class="API" base="twisted.web">woven.widgets</code>, 
<code class="API" base="twisted.web">woven.input</code> is used as a default
controller namespace when searching for controller names.
</p>

<p>
The <code class="API" base="twisted.web.woven.input">Anything</code> 
<code class="API" base="twisted.web.woven.input">InputHandler</code> looks in
the request arguments for data with the same
name as its model name. In this case, the model name is <q>quote</q>, and the
input node also has the name <q>quote</q>. When the form is submitted, the
value of the text field will be available in the request arguments as
<q>quote</q>, and the
<code class="API" base="twisted.web.woven.input">Anything</code> 
<code class="API" base="twisted.web.woven.input">InputHandler</code> will find
it. The 
<code class="API" base="twisted.web.woven.input">Anything</code> 
<code class="API" base="twisted.web.woven.input">InputHandler</code> then
immediately
calls <code>model.setData(value)</code> since it does no input validation.
</p>

<pre>
Under construction.
</pre>
<p>
Next up: Implementing custom view logic with wvupdate, and creating and using
reusable <code class="API" base="twisted.web.woven.widgets">Widget</code> and 
<code class="API" base="twisted.web.woven.input">InputHandler</code> subclasses
with wvfactory and wcfactory.
</p>

</body>
</html>
