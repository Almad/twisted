<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>Twisted from Scratch, or The Evolution of Finger</title>
  </head>
<body>

<h1>Twisted from Scratch, or The Evolution of Finger</h1>

<h2>Introduction</h2>

<p>
Twisted is a big system. People are often daunted when they approach it. It's
hard to know where to start looking.
</p>

<p>
This guide builds a full-fledged Twisted application from the ground up, using
most of the important bits of the framework. There is a lot of code, but don't
be afraid.
</p>

<p>
The application we are looking at is a <q>finger</q> service, along the 
lines of the familiar service traditionally provided by UNIX&trade; servers. 
We will extend this service slightly beyond the standard, in order to 
demonstrate some of Twisted's higher-level features.
</p>

<h2>Refuse Connections</h2>

<a href="listings/finger/finger01.py" class="py-listing">finger01.py</a>

<p>This example only runs the reactor. Nothing at all will happen until we
interrupt the program.  It will consume almost no CPU resources. Not very
useful, perhaps -- but this is the skeleton inside which the Twisted program
will grow.
</p>

<h3>The Reactor</h3>

<p>
You don't call Twisted, Twisted calls you. The <code class="API" base="twisted.internet">reactor</code> is Twisted's
main event loop. There is exactly one reactor in any running Twisted
application. Once started it loops over and over again, responding to network
events, and making scheduled calls to code.
</p>


<h2>Do Nothing</h2>

<a href="listings/finger/finger02.py" class="py-listing">finger02.py</a>

<p>Here, we start listening on port 1079. The 1079 is a reminder that
eventually, we want to run on port 79, the standard port for finger servers.
We define a protocol which does not respond to any events. Thus, connections to
1079 will be accepted, but the input ignored.</p>


<h2>Drop Connections</h2>

<a href="listings/finger/finger03.py" class="py-listing">finger03.py</a>

<p>Here we add to the protocol the ability to respond to the event of beginning
a connection -- by terminating it.  Perhaps not an interesting behavior, but
it is already close to behaving according to the letter of the protocol. After
all, there is no requirement to send any data to the remote connection in the
standard.  The only problem, as far as the standard is concerned, is that we
terminate the connection too soon. A client which is slow enough will see his
send() of the username result in an error.</p>


<h2>Read Username, Drop Connections</h2>

<a href="listings/finger/finger04.py" class="py-listing">finger04.py</a>

<p>Here we make <code>FingerProtocol</code> inherit from <code class="API"
base="twisted.protocols.basic">LineReceiver</code>, so that we get data-based
events on a line-by-line basis. We respond to the event of receiving the line
with shutting down the connection.
</p>

<p>Congratulations, this is the first standard-compliant version of the code.
However, usually people actually expect some data about users to be
transmitted.</p>


<h2>Read Username, Output Error, Drop Connections</h2>

<a href="listings/finger/finger05.py" class="py-listing">finger05.py</a>

<p>Finally, a useful version. Granted, the usefulness is somewhat
limited by the fact that this version only prints out a <q>No such user</q>
message. It could be used for devastating effect in honey-pots,
of course.</p>


<h2>Output From Empty Factory</h2>

<a href="listings/finger/finger06.py" class="py-listing">finger06.py</a>

<p>The same behavior, but finally we see what usefulness the
factory has: as something that does not get constructed for
every connection, it can be in charge of the user database.
In particular, we won't have to change the protocol if
the user database back-end changes.</p>


<h2>Output from Non-empty Factory</h2>

<a href="listings/finger/finger07.py" class="py-listing">finger07.py</a>

<p>Finally, a really useful finger database. While it does not
supply information about logged in users, it could be used to
distribute things like office locations and internal office
numbers. As hinted above, the factory is in charge of keeping
the user database: note that the protocol instance has not
changed. This is starting to look good: we really won't have
to keep tweaking our protocol.</p>


<h2>Use Deferreds</h2>

<a href="listings/finger/finger08.py" class="py-listing">finger08.py</a>

<p>But, here we tweak it just for the hell of it. Yes, while the
previous version worked, it did assume the result of getUser is
always immediately available. But what if instead of an in memory
database, we would have to fetch result from a remote Oracle?
Or from the web? Or, or...</p>


<h2>Run 'finger' Locally</h2>

<a href="listings/finger/finger09.py" class="py-listing">finger09.py</a>

<p>...from running a local command? Yes, this version runs
finger locally with whatever arguments it is given, and returns the
standard output. This is probably insecure, so you probably don't
want a real server to do this without a lot more validation of the
user input. This will do exactly what the standard version
of the finger server does.</p>


<h2>Read Status from the Web</h2>

<p>The web. That invention which has infiltrated homes around the
world finally gets through to our invention. Here we use the built-in
Twisted web client, which also returns a deferred. Finally, we manage
to have examples of three different database back-ends, which do
not change the protocol class. In fact, we will not have to change
the protocol again until the end of this tutorial: we have achieved,
here, one truly usable class.</p>

<a href="listings/finger/finger10.py" class="py-listing">finger10.py</a>




<h2>Use Application</h2>

<p>Up until now, we faked. We kept using port 1079, because really,
who wants to run a finger server with root privileges? Well, the
common solution is <q>privilege shedding</q>: after binding to the network,
become a different, less privileged user. We could have done it ourselves,
but Twisted has a built-in way to do it. Create a snippet as above,
defining an application object. That object will have uid and gid
attributes. When running it (later we will see how) it will bind
to ports, shed privileges and then run.</p>

<p>After saving the example below as <q>finger.tac</q>, read on to find out
how to run this code using the twistd utility.</p>

<a href="listings/finger/finger11.py" class="py-listing">finger11.py</a>



<h2>twistd</h2>

<p>This is how to run <q>Twisted Applications</q> -- files which define an
'application'. twistd (TWISTed Daemonizer) does everything a daemon
can be expected to -- shuts down stdin/stdout/stderr, disconnects
from the terminal and can even change runtime directory, or even
the root filesystems. In short, it does everything so the Twisted
application developer can concentrate on writing his networking code.
</p>

<pre class="shell">
root% twistd -ny finger.tac # just like before
root% twistd -y finger.tac # daemonize, keep pid in twistd.pid
root% twistd -y finger.tac --pidfile=finger.pid
root% twistd -y finger.tac --rundir=/
root% twistd -y finger.tac --chroot=/var
root% twistd -y finger.tac -l /var/log/finger.log
root% twistd -y finger.tac --syslog # just log to syslog
root% twistd -y finger.tac --syslog --prefix=twistedfinger # use given prefix
</pre>


<h2>Setting Message By Local Users</h2>

<p>Now that port 1079 is free, maybe we can run on it a different
server, one which will let people set their messages. It does
no access control, so anyone who can login to the machine can
set any message. We assume this is the desired behavior in
our case. Testing it can be done by simply:
</p>

<pre class="shell">
% nc localhost 1079   # or telnet localhost 1079
moshez
Giving a tutorial now, sorry!
^D
</pre>

<a href="listings/finger/finger12.py" class="py-listing">finger12.py</a>


<h2>Use Services to Make Dependencies Sane</h2>

<p>The previous version had the setter poke at the innards of the
finger factory. It's usually not a good idea: this version makes
both factories symmetric by making them both look at a single
object. Services are useful for when an object is needed which is
not related to a specific network server. Here, we moved all responsibility
for manufacturing factories into the service. Note that we stopped
subclassing: the service simply puts useful methods and attributes
inside the factories. We are getting better at protocol design:
none of our protocol classes had to be changed, and neither will
have to change until the end of the tutorial.</p>

<a href="listings/finger/finger13.py" class="py-listing">finger13.py</a>




<h2>Read Status File</h2>

<p>This version shows how, instead of just letting users set their
messages, we can read those from a centrally managed file. We cache
results, and every 30 seconds we refresh it. Services are useful
for such scheduled tasks.</p>

<a href="listings/finger/etc.users" class="listing">sample /etc/users file</a>

<a href="listings/finger/finger14.py" class="py-listing">finger14.py</a>


<h2>Announce on Web, Too</h2>

<p>The same kind of service can also produce things useful for
other protocols. For example, in twisted.web, the factory
itself (the site) is almost never subclassed -- instead,
it is given a resource, which represents the tree of resources
available via URLs. That hierarchy is navigated by site,
and overriding it dynamically is possible with getChild.</p>

<a href="listings/finger/finger15.py" class="py-listing">finger15.py</a>


<h2>Announce on IRC, Too</h2>

<p>This is the first time there is client code. IRC clients often
act a lot like servers: responding to events from the network.
The reconnecting client factory will make sure that severed links
will get re-established, with intelligent tweaked exponential
back-off algorithms. The IRC client itself is simple: the only
real hack is getting the nickname from the factory in connectionMade.</p>

<a href="listings/finger/finger16.py" class="py-listing">finger16.py</a>


<h2>Add XML-RPC Support</h2>

<p>In Twisted, XML-RPC support is handled just as though it was
another resource. That resource will still support GET calls normally
through render(), but that is usually left unimplemented. Note
that it is possible to return deferreds from XML-RPC methods.
The client, of course, will not get the answer until the deferred
is triggered.</p>

<a href="listings/finger/finger17.py" class="py-listing">finger17.py</a>

<p>A simple client to test the XMLRPC finger:</p>

<a href="listings/finger/fingerXRclient.py" class="py-listing">fingerXRclient.py</a>


<h2>Write Readable Code</h2>

<p>The last version of the application had a lot of hacks. We avoided
sub-classing, didn't support things like user listings over the web, 
and removed all blank lines -- all in the interest of code
which is shorter. Here we take a step back, subclass what is more
naturally a subclass, make things which should take multiple lines
take them, etc. This shows a much better style of developing Twisted
applications, though the hacks in the previous stages are sometimes
used in throw-away prototypes.</p>

<a href="listings/finger/finger18.py" class="py-listing">finger18.py</a>


<h2>Write Maintainable Code</h2>


<p>In the last version, the service class was three times longer than
any other class, and was hard to understand. This was because it turned
out to have multiple responsibilities. It had to know how to access
user information, by rereading the file every half minute,
but also how to display itself in a myriad of protocols. Here, we
used the component-based architecture that Twisted provides to achieve
a separation of concerns. All the service is responsible for, now,
is supporting getUser/getUsers. It declares its support via the
__implements__ keyword. Then, adapters are used to make this service
look like an appropriate class for various things: for supplying
a finger factory to TCPServer, for supplying a resource to site's
constructor, and to provide an IRC client factory for TCPClient.
All the adapters use are the methods in FingerService they are
declared to use: getUser/getUsers. We could, of course,
skip the interfaces and let the configuration code use
things like FingerFactoryFromService(f) directly. However, using
interfaces provides the same flexibility inheritance gives: future
subclasses can override the adapters.</p>

<a href="listings/finger/finger19.py" class="py-listing">finger19.py</a>



<h2>Advantages of Latest Version</h2>

<ul>
<li>Readable -- each class is short</li>
<li>Maintainable -- each class knows only about interfaces</li>
<li>Dependencies between code parts are minimized</li>
<li>Example: writing a new IFingerService is easy</li>
</ul>
<a href="listings/finger/finger19a_changes.py" class="py-listing">finger19a_changes.py</a>
<p>
Full source code here: <a class="py-listing" href="listings/finger/finger19a.py">finger19a.py</a>
</p>

<p>Here we show just how convenient it is to implement new back-ends
when we move to a component based architecture. Note that here
we also use an interface we previously wrote, FingerSetterFactory,
by supporting one single method. We manage to preserve the service's
ignorance of the network.</p>


<h2>Another Back-end</h2>

<a href="listings/finger/finger19b_changes.py" class="py-listing">finger19b_changes.py</a>
<p>
Full source code here: <a class="py-listing" href="listings/finger/finger19b.py">finger19b.py</a>
</p>

<p>We've already written this, but now we get more for less work:
the network code is completely separate from the back-end.</p>


<h2>Yet Another Back-end: Doing the Standard Thing</h2>

<a href="listings/finger/finger19c_changes.py" class="py-listing">finger19c_changes.py</a>
<p>
Full source code here: <a class="py-listing" href="listings/finger/finger19c.py">finger19c.py</a>
</p>

<p>Not much to say except that now we
can be churn out backends like crazy. Feel like doing a back-end
for Advogato, for example? Dig out the XML-RPC client support Twisted
has, and get to work!</p>


<h2>Aspect-Oriented Programming</h2>

<p>At last, an example of aspect-oriented programming that isn't about logging
or timing. This code is actually useful! Watch how aspect-oriented programming
helps you write less code and have fewer dependencies!
</p>


<h2>Use Woven</h2>

<p>Here we convert to using Woven, instead of manually constructing HTML
snippets. Woven is a sophisticated web templating system. Its main features are
to disallow any code inside the HTML, and transparent integration with deferred
results.</p>

<a href="listings/finger/finger20.py" class="py-listing">finger20.py</a>


<h2>Use Perspective Broker</h2>

<p>We add support for perspective broker, Twisted's native remote object
protocol. Now, Twisted clients will not have to go through XML-RPCish
contortions to get information about users.</p>

<a href="listings/finger/finger21.py" class="py-listing">finger21.py</a>

<p>A simple client to test the perspective broker finger:</p>

<a href="listings/finger/fingerPBclient.py" class="py-listing">fingerPBclient.py</a>



<h2>Support HTTPS</h2>

<p>All we need to do to code an HTTPS site is just write a context factory (in
this case, which loads the certificate from a certain file) and then use the
twisted.application.internet.SSLServer method. Note that one factory (in this case, a site) can listen on multiple ports with multiple protocols.</p>

<a href="listings/finger/finger22.py" class="py-listing">finger22.py</a>



<h2>Finger Proxy</h2>

<p>Writing new clients with Twisted is much like writing new servers.
We implement the protocol, which just gathers up all the data, and
give it to the factory. The factory keeps a deferred which is triggered
if the connection either fails or succeeds. When we use the client,
we first make sure the deferred will never fail, by producing a message
in that case. Implementing a wrapper around client which just returns
the deferred is a common pattern.  While less flexible than
using the factory directly, it's also more convenient.</p>


<a href="listings/finger/fingerproxy.py" class="py-listing">fingerproxy.py</a>



<h2>Organization</h2>

<p>Now this code, while quite modular and well-designed, isn't
properly organized. Everything above the <code>application=</code> belongs in a
module, and the HTML templates all belong in separate files.
</p>

<p>We can use the templateFile and templateDirectory attributes to indicate
what HTML template file to use for each Page, and where to look for it.</p>

<a href="listings/finger/organized-finger.tac" class="py-listing">organized-finger.tac</a>

<p>
Note that our program is now quite separated. We have:
<ul>
  <li>Code (in the module)</li>
  <li>Configuration (file above)</li>
  <li>Presentation (templates)</li>
  <li>Content (/etc/users)</li>
  <li>Deployment (twistd)</li>
</ul>

Prototypes don't need this level of separation, so our earlier examples all
bunched together. However, real applications do. Thankfully, if we write our
code correctly, it is easy to achieve a good separation of parts.
</p>


<h2>Easy Configuration</h2>

<p>We can also supply easy configuration for common cases with a makeService method that will also help build .tap files later:</p>

<a href="listings/finger/finger_config.py" class="py-listing">finger_config.py</a>

<p>And we can write simpler files now:</p>

<a href="listings/finger/simple-finger.tac" class="py-listing">simple-finger.tac</a>

<pre class="shell">
% twisted -ny simple-finger.tac
</pre>


<p>Note: the finger <em>user</em> still has ultimate power: he can use
makeService, or he can use the lower-level interface if he has
specific needs (maybe an IRC server on some other port? maybe we
want the non-SSL webserver to listen only locally?  etc. etc.)
This is an important design principle: never force a layer of abstraction:
allow usage of layers of abstractions.</p>

<p>The pasta theory of design:</p>

<ul>
<li>Spaghetti: each piece of code interacts with every other piece of
    code [can be implemented with GOTO, functions, objects]</li>
<li>Lasagna: code has carefully designed layers. Each layer is, in
    theory independent. However low-level layers usually cannot be
    used easily, and high-level layers depend on low-level layers.</li>
<li>Ravioli: each part of the code is useful by itself. There is a thin
    layer of interfaces between various parts [the sauce]. Each part
    can be usefully be used elsewhere.</li>
<li>...but sometimes, the user just wants to order <q>Ravioli</q>, so one
    coarse-grain easily definable layer of abstraction on top of it all
    can be useful.</li>
</ul>


<h2>Plugins</h2>

<p>So far, the user had to be somewhat of a programmer to be able to configure
stuff. Maybe we can eliminate even that? Move old code to finger/__init__.py and...</p>
<p>
Full source code for finger module here: <a class="py-listing" href="listings/finger/finger/finger.py">finger module</a>
</p>

<a href="listings/finger/finger/tap.py" class="py-listing">finger/tap.py</a>

<p>And register it all:</p>

<a href="listings/finger/finger/plugins.tml" class="py-listing">finger/plugins.tml</a>

<p>And now, the following works</p>

<pre class="shell">
% mktap finger --file=/etc/users --ircnick=fingerbot
% sudo twistd -nf finger.tap
</pre>

<h2>OS Integration</h2>

<p>If we already have the <q>finger</q> package installed in
PYTHONPATH (e.g.  we added it to site-packages), we can achieve easy
integration:</p>

<h3>Debian</h3>

<pre class="shell">
% tap2deb --unsigned -m "Foo &lt;foo@example.com&gt;" --type=python finger.tac
% sudo dpkg -i .build/*.deb
</pre>

<h3>Red Hat / Mandrake</h3>

<pre class="shell">
% tap2rpm --type=python finger.tac #[maybe other options needed]
% sudo rpm -i .build/*.rpm
</pre>

<p>Will properly register the tap/tac, init.d scripts, etc. for the given file.</p>

<p>If it doesn't work on your favorite OS: patches accepted!</p>

</body>
</html>
