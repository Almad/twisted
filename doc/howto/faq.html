<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
<head><title>The Twisted FAQ</title></head>
<body>
<h1>The Twisted FAQ</h1>

<h2>What is <q>Twisted</q>?</h2>

<p>Please see
<a href="http://twistedmatrix.com/products/twisted">Twisted</a>
</p>

<h2>Why should I use Twisted?</h2>

<p>See <a href="http://twistedmatrix.com/services/twisted-advantage">The
Twisted Advantage</a></p>

<h2>I have a problem <q>getting</q> Twisted.</h2>

<p>Did you check the HOWTO collection? There are so many documents there
that they might overwhelm you...try starting from the index, reading through
the overviews and seeing if there seems to be a chapter which explains what
you need to. You can try reading the PostScript or PDF formatted books,
inside the distribution. And, remember, the source will be with
you...always.</p>


<h2>Why is Twisted so big?</h2>

<p>Twisted is a lot of things, rolled into one big package. We're not sure if 
it'll stay this way, yet, but for now, if you have only specific needs, we
recommend grabbing the big Twisted tarball, and if you want, you can run the
'setup.py' script with a modified config file to generate a package with only
certain Twisted sub-packages. Twisted as a whole makes it into many operating 
system distributions (FreeBSD, Debian and Gentoo, at least) so size shouldn't
be an issue for the end developer or user. In addition, packaging Twisted
as a whole makes sure the end users do not have to worry about versioning
parts of Twisted and inter-version compatibility.</p>

<p>If you are distributing Twisted to end-users, you can base your distribution
on the <q>Nodocs</q> packages, which are signficantly smaller.</p>

<h2>But won't Twisted bloat my program, since it's so big?</h2>

<p>No. You only need to import the sub-packages which you want to use, meaning
only those will be loaded into memory. So if you write a low-level network
protocol, you'd only import twisted.internet, leaving out extraneous things
like twisted.web, etc. Twisted itself is very careful with internal
dependancies, so importing one subpackage is not likely to import the whole
twisted package.</p>

<h2>Does the 1.0 release mean that all of Twisted's APIs are stable?</h2>

<p>No, only specific parts of Twisted are stable, i.e. we only promise
backwards compatibility for some parts of Twisted. While these APIs may be
extended, they will not change in ways that break existing code that uses
them. </p>

<p>While other parts of Twisted are not stable, we will however do
our best to make sure that there is backwards compatibility for these parts
as well. In general, the more the module or package are used, and the closer they
are to being feature complete, the more we will concentrate on providing backwards
compatibility when API changes take place.</p>

<h2>Which parts of Twisted 1.0 are stable?</h2>

<p>Only modules explictily marked as such can be considered stable. Semi-stable
modules may change, but not in a large way and some sort of backwards-compatibily
will probably be provided. If no comment about API stability is present, assume
the module is unstable.</p>

<p>In Twisted 1.0, <em>most of twisted.internet is completely stable</em>, other than:

<ol>
<li>UDP support</li>
<li>twisted.internet.win32eventreactor - will be replaced with win32support in future.</li>
</ol>

But as always, the only accurate way of knowing a module's stability is reading
the module's docstrings.</p>

<h2>How can I access self.factory from my Protocol's __init__?</h2>

<p>You can't.  A Protocol doesn't have a Factory when it is created.  Instead,
you should probably be doing that in your Protocol's
<code>connectionMade</code> method.</p>

<p>Similarly you shouldn't be doing <q>real</q> work, like connecting to
databases, in a Factory's <code>__init__</code> either.  Instead, do that in
<code>startFactory</code>.</p>

<p>See <a href="servers.html">Writing Servers</a> and 
<a href="clients.html">Writing Clients</a> for more details.</p>

<h2>Is the Twisted web server a toy?</h2>

<p>No. It is a production grade server. It is running continously on several
sites and has been proven quite stable. The server can take loads of up to 3000
users at a time and still keep churning several million requests a day, even on
low end hardware. It can serve static files or dynamically rendered pages.</p>

<h2>But can Twisted Web do PHP?</h2>

<p>Yes.  It works out-of-the-box, so long as you've got the standalone php
interpreter installed.  You might also want to take a look at Woven, Twisted's
native web templating system.</p>

<h2>And can Twisted Web do virtual hosting?</h2>

<p>Can it ever!</p>

<p>You can decide to go with one big process for all of them, a front server
and a seperate server for each virtual host (for example, for permission
reasons), and you can even mix-and-math between Apache and Twisted (for
example, put Apache in the front and have Twisted handle some subset of the
virtual host).</p>

<h2>Where can I find out how to write Twisted servers?</h2>

<p>Try <a href="http://www.twistedmatrix.com/documents/howto/servers">Writing
Servers</a>.</p> 

<h2>Twisted is cool, but I need to add more functionality.</h2>

<p>Great! Read our the docs, and if you're feeling generous, contribute
patches.</p>

<h2>I have a patch. How do I maximize the chances the Twisted developers
will include it?</h2>

<p>Use unified diff. Either use <code class="shell">cvs diff -u</code> or,
better yet, make a clean checkout and use
<code class="shell">diff -urN</code> between them. Make sure your patch
applies cleanly. Then, send it to the mailing list inlined and without
any word wrapping.</p> 

<h2>Twisted really needs documentation for X, Y or Z - how come it's not documented?.</h2>

<p>We are doing the best we can, and there is documentation
in progress for many parts of Twisted. There is a limit to how much we
can do in our free time. See also the answer to the next question.</p>

<h2>My company would love to use Twisted, but it's missing feature X, can you implement it?</h2>

<p>You have 3 options:</p>

<ul>
<li>Pay one of the Twisted developers to implement the feature.</li>
<li>Implement the feature yourself.</li>
<li>Add a feature request to our bug tracker. We will try to implement the
feature, but there are no guarantees when and if this will happen.</li>
</ul>

<h2>Help!</h2>

<p>Ask for help <a href="http://twistedmatrix.com/services/online-help">where
the Twisted team hangs out</a></p>

<h2>I have this cool patch. To whom do I send it?</h2>

<p>To the <a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing list</a>.
If no one picks it up after a days, it's recommended that you add it to the 
<a href="http://sourceforge.net/tracker/?group_id=49387&amp;atid=456015">bug tracker</a> so that
it doesn't get lost.</p>

<h2>There's a bug in Twisted. Where do I report it?</h2>

<p>Unless it is a show-stopper bug, we usually won't fix it if it's already
fixed in <a href="http://twistedmatrix.com/developers/cvs">CVS</a>, so you
would do well to look there. Then send any pertinent information about the
bug (hopefully as much information needed to reproduce it: OS, CVS versions
of any important files, Python version, code you wrote or things you did
to trigger the bug, etc.) to the <a href="http://twistedmatrix.com/cgi-bin/mailman/listinfo/twisted-python">mailing list</a>. If no one answers immediately, you should add it to the 
<a href="http://sourceforge.net/tracker/?group_id=49387&amp;atid=456015">bug tracker</a>.</p>

<h2>How do I use twisted.web to do complex things?</h2>

<p>See <a href="using-twistedweb.html">the Twisted.Web Howto</a>.</p>

<h2>I've been using Woven since before it was called Woven.  I just upgraded
and now I'm getting a confusing traceback talking about INodeMutator. What
gives?</h2>

<p>You probably have code that's survived the upgrade from PyXML's
<code>minidom</code> to Twisted's <code>microdom</code>.  Try deleting any
<code>.pxp</code> files that you have lying around and the error will probably
go away.</p>

<h2>When I try to install my reactor, I get errors about a reactor
already being installed. What gives?</h2>

<p>Here's the rule - installing a reactor should always be the
<strong>first</strong> thing you do, and I do mean first. Importing other stuff
before you install the reactor can break your code.</p>

<p>Tkinter and wxPython support, as they do not install a new reactor, can be
done at any point, IIRC.</p>

<h2>Wow the Twisted documentation is nice! I want my docs to look like that
to!</h2>

<p>Now you can, with <code class="API">twisted.lore</code>. See the manual
pages for <code>generatelore</code> and <code>html2latex</code>. For
source format documentation, see <a href="doc-standard.html">the documentation
standard description</a>.</p>

<h2><code>twistd</code> won't load my <code>.tap</code> file!</h2>

<p>When the pickled application state cannot be loaded for some reason, it
is common to get a rather opaque error like so:</p>

<pre class="shell">
% twistd -f test2.tap 

Failed to load application: global name 'initRun' is not defined
</pre>

<p>To load a <code>.tap</code> file, as with any unpickling operation, all
the classes used by all the objects inside it must be accessible at the time
of the reload. This may require the PYTHONPATH variable to have the same
directories as were available when the application was first pickled.</p>

<p>A common problem occurs in single-file programs which define a few
classes, then create instances of those classes for use in a server of some
sort. If the class is used directly, the name of the class will be recorded
in the <code>.tap</code> file as something like
<code>__main__.MyProtocol</code>. When the application is reloaded, it will
look for the class definition in <code>__main__</code>, which probably won't
have it. The unpickling routines need to know the module name, and therefore
the source file, from which the class definition can be loaded.</p>

<p>The way to fix this is to import the class from the same source file that
defines it: if your source file is called <code>myprogram.py</code> and
defines a class called <code>MyProtocol</code>, you will need to do a
<code>from myprogram import MyProtocol</code> before (and in the same
namespace as) the code that references the MyProtocol class. This makes it
important to write the module cleanly: doing an <code>import
myprogram</code> should only define classes, and should not cause any other
subroutines to get run. All the code that builds the Application and saves
it out to a <code>.tap</code> file must be inside an <code>if __name__ ==
'__main__'</code> clause to make sure it is not run twice (or more).</p>

<p>When you import the class from the module using an <q>external</q> name,
that name will be recorded in the pickled <code>.tap</code> file. When the
<code>.tap</code> is reloaded by <code>twistd</code>, it will look for
<code>myprogram.py</code> to provide the definition of
<code>MyProtocol</code>.</p>

<p>For a short example of this technique, take a look at <a
href="../examples/echoserv.py">doc/examples/echoserv.py</a></p>

</body>
</html>
