<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>Authentication with Perspective Broker</title>

<style src="stylesheet-unprocessed.css"></style>

</head>

<body>
<h1>Authentication with Perspective Broker</h1>

<h2>Motivation</h2>

<p>In the examples shown in <a href="pb-usage.xhtml">Using Perspective
Broker</a> there were some problems. You had to trust the user when they
said their name was <q>bob</q>: no passwords or anything. If you wanted a
direct-send one-to-one message feature, you might have implemented it by
handing a User reference directly off to another User. (so they could invoke
<code>.remote_sendMessage()</code> on the receiving User): but that lets
them do anything else to that user too, things that should probably be
restricted to the <q>owner</q> user, like <code>.remote_joinGroup()</code>
or <code>.remote_quit()</code>.</p>

<p>And there were probably places where the easiest implementation was to
have the client send a message that included their own name as an argument.
Sending a message to the group could just be:</p>

<pre class="python">
class Group(pb.Referenceable):

# ...

  def remote_sendMessage(self, from_user, message):
    for user in self.users:
      user.callRemote("sendMessage", "[%s]: %s" % (from_user, message))
</pre>

<p>But obviously this lets users spoof each other: there's no reason that
Alice couldn't do:</p>

<pre class="python">
remotegroup.callRemote("sendMessage", "bob", "i like pork")
</pre>

<p>much to the horror of Bob's vegetarian friends.</p>

<p>(In general, learn to get suspicious if you see
<code>groupName</code> or <code>userName</code>
in the argument list of a remotely-invokable method).</p>

<p>You could fix this by adding more classes (with fewer remotely-invokable
methods), and making sure that the reference you give to Alice won't let her
pretend to be anybody else. You'd probably give Alice her own object, with
her name buried inside:</p>

<pre class="python">
class User(pb.Referenceable):
  def __init__(self, name):
    self.name = name
  def remote_sendMessage(self, group, message):
    g = findgroup(group)
    for user in g.users:
      user.callRemote("sendMessage", "[%s]: %s" % (self.name, message))
</pre>

<p>This improves matters because, as long as Alice only has a reference to
<em>this</em> object and nobody else's, she can't cause a different
<code>self.name</code> to get used. Of course, you have to make sure that
you don't give her a reference to the wrong object.</p>

<div class="note">
<p>Third party references (there aren't any)</p>

<p>Note that the reference that the server gives to a client is only useable
by that one client: if they try to hand it off to a third party, they'll get
an exception (XXX: which? looks like an assert in pb.py:290
RemoteReference.jellyFor). This helps somewhat: only the client you gave the
reference to can cause any damage with it. Of course, the client might be a
brainless zombie, simply doing anything some third party wants. When it's
not proxying <code>callRemote</code> invocations, it's probably terrorizing
the living and searching out human brains for sustenance. In short, if you
don't trust them, don't give them that reference.</p>

<p>Also note that the design of the serialization mechanism (implemented in
<code class="API">twisted.spread.jelly</code>: pb, jelly, spread.. get it?
Also look for <q>banana</q> and <q>marmalade</q>. What other networking
framework can claim API names based on sandwich ingredients?) makes it
impossible for the client to obtain a reference that they weren't explicitly
given. References passed over the wire are given id numbers and recorded in
a per-connection dictionary. If you didn't give them the reference, the id
number won't be in the dict, and no amount of id guessing by a malicious
client will give them anything else. The dict goes away when the connection
is dropped, limiting further the scope of those references.</p>

<p>Of course, everything you've ever given them over that connection can
come back to you. If expect the client to invoke your method with some
object A that you sent to them earlier, and instead they send you object B
(that you also sent to them earlier), and you don't check it somehow, then
you've just opened up a security hole. It may be better to keep such objects
in a dictionary on the server side, and have the client send you an index
string instead. Doing it that way makes it obvious that they can send you
anything they want, and improves the chances that you'll remember to
implement the right checks. (This is exactly what PB is doing underneath,
with a per-connection dictionary of <code>Referenceable</code> objects,
indexed by a number).</p>
</div>

<p>But now she could sneak into another group. So you might have to have an
object per-group-per-user:</p>


<pre class="python">
class UserGroup(pb.Referenceable):
  def __init__(self, group, user):
    self.group = group
    self.user = user
  def remote_sendMessage(self, message):
    name = self.user.name
    for user in self.group.users:
      user.callRemote("sendMessage", "[%s]: %s" % (name, message))
</pre>


<p>But that means more code, and more code is bad, especially when it's a
common problem (everybody designs with security in mind, right?
Right??).</p>


<p>So we have a security problem. We need a way to ask for and verify a
password, so we know that Bob is really Bob and not Alice wearing her <q>Hi,
my name is Bob</q> t-shirt. And it would make the code cleaner (i.e.: fewer
classes) if some methods could know reliably <em>who</em> is calling
them.</p>

<h2>A sample application</h2>

<p>As a framework for this chapter, we'll be referring to a hypothetical
game implemented by several programs using the Twisted framework. This game
will have multiple players, where users log in using their client programs,
and there is a server, and users can do some things but not
others<span class="footnote">There actually exists such a thing. It's called
twisted.reality, and was the whole reason Twisted was created. I haven't
played it yet: I'm too afraid.</span>.</p>

<p>The players make moves in this game by invoking remote methods on objects
that live in the server. The clients can't really be relied upon to tell the
server who they are with each move they make: they might get it wrong, or
(horrors!) lie to mess up the other player.</p>

<p>Let's simplify it to a server-based game of Go (if that can be considered
simple). Go has two players, white and black, who take turns placing stones
of their own color at the intersections of a 19x19 grid. If we represent the
game and board as an object in the server called Game, then the players
might interact with it using something like this:</p>

<pre class="python">
class Game(pb.Referenceable):
  def remote_getBoard(self):
    return self.board # a dict, with the state of the board
  def remote_move(self, playerName, x, y):
    self.board[x,y] = playerName
</pre>

<p><q>But Wait</q>, you say, yes that method takes a playerName, which means
they could cheat and move for the other player. So instead, do this:</p>

<pre class="python">
class Game(pb.Referenceable):
  def remote_getBoard(self):
    return self.board # a dict, with the state of the board
  def move(self, playerName, x, y):
    self.board[x,y] = playerName
</pre>

<p>and move the responsibility (and capability) for calling Game.move() out
to a different class. That class is a 
<code class="API" base="twisted.spread">pb.IPerspective</code>.</p>

<h2>Perspectives</h2>

<p><code class="API" base="twisted.spread">pb.IPerspective</code> 
(and the convenience implementation 
<code class="API" base="twisted.spread">pb.Avatar</code>)
is a layer on top of the
basic PB system that handles username/password checking. The basic idea is
that there is a separate IPerspective object (probably a subclass 
of <code>Avatar</code> you've
created) for each user<span class="footnote">Actually there is a perspective
per user*realm, but we'll get into that later</span>, and <em>only</em>
the authorized user gets a remote reference to that IPerspective object. You
can store whatever permissions or capabilities the user possesses in that
object, and then use them when the user invokes a remote method. You give
the user access to the Perspective object instead of the objects that do the
real work.</p>

<p>Your code can then look like this:</p>

<pre class="python">
class Game:
  def getBoard(self):
    return self.board # a dict, with the state of the board
  def move(self, playerName, x, y):
    self.board[x,y] = playerName

class PlayerPerspective(pb.Avatar):
  def __init__(self, playerName, game):
    self.playerName = playerName
    self.game = game
  def perspective_move(self, x, y):
    self.game.move(self.playerName, x, y)
  def perspective_getBoard(self):
    return self.game.getBoard()
</pre>

<p>The code on the server side creates the PlayerPerspective object, giving
it the right playerName and a reference to the Game object. The remote
player doesn't get a reference to the Game object, only their own
PlayerPerspective, so they don't have an opportunity to lie about their
name: it comes from the <code class="python">.playerName</code> attribute,
not an argument of their remote method call.</p>

<p>Here is a brief example of using a Perspective. Most of the support code
is magic for now: we'll explain it later.</p>

<a href="listings/pb/pb5server.py" class="py-listing">pb5server.py</a>
<a href="listings/pb/pb5client.py" class="py-listing">pb5client.py</a>

<p>Ok, so that wasn't really very exciting. It doesn't accomplish much more
than the first PB example, and used a lot more code to do it. Let's try it
again with two users this time.</p>

<div class="note">

<p>When the client runs <code>login</code> to request the Perspective,
they can provide it with an optional <code>client</code> argument (which
must be a <code>pb.Referenceable</code> object). If they do, then a
reference to that object will be handed to the realm's
<code>requestAvatar</code> in the <code>mind</code> argument.</p>

<p>The server-side Perspective can use it to invoke remote methods on
something in the client, so that the client doesn't always have to drive the
interaction. In a chat server, the client object would be the one to which
<q>display text</q> messages were sent. In a game, this would provide a way
to tell the clients that someone has made a move, so they can update their
game boards.</p>

</div>

<a href="listings/pb/pb6server.py" class="py-listing">pb6server.py</a>
<a href="listings/pb/pb6client1.py" class="py-listing">pb6client1.py</a>
<a href="listings/pb/pb6client2.py" class="py-listing">pb6client2.py</a>

<p>While pb6server.py is running, try starting pb6client1, then pb6client2.
Compare the argument passed by the <code>.callRemote()</code> in each
client. You can see how each client logs into a different Perspective.</p>


<h2>Class Overview</h2><a name="overview" />

<p>Now that we've seen some of the motivation behind the Perspective class,
let's start to de-mystify some of the parts labeled <q>magic</q> in
<code>pb6server.py</code>. Most of the major classes involved are
described in <a href="newcred.xhtml">the cred howto</a>.</p>

<p>The <code>Avatar</code> subclass implements pb.IPerspective and also
whatever <code>perspective_*</code> methods you wish to
expose to an authenticated remote user. It usually gets the name
of the user from the <code>Realm</code>.</p>


<h2>How that example worked</h2><a name="smallexample" />

<p>Ok, so that's what everything is supposed to do. Now you can walk through
the previous example and see what was going on: we created a subclass called
<code>MyPerspective</code>, created an <code>IRealm</code> which manufactures
<code>MyPerspective</code> objects, created a portal to hold this realm
and registered a simple <code>IChecker</code> to hold valid user/password
pairs. In more complicated situations, the realm could cache the
<code>MyPerspective</code> objects. Then we wrapped the <code>Portal</code>
in <code>pb.PBServerFactory</code>. This connects the portal to an
actual network protocol -- in this case, PB.</p>

<h2>Code Walkthrough: pb.PBClientFactory</h2><a name="walkthrough" />

<p>So, now that you've seen the complete sequence, it's time for a code
walkthrough. This will give you a chance to see the places where you might
write subclasses to implement different behaviors. We will look at what
happens when <code>pb6client1.py</code> meets <code>pb6server.py</code>. We
tune in just as the client has run the <code
class="python">login()</code> call.</p>

<p>The client-side code can be summarized by the following sequence of
function calls, all implemented in twisted/spread/pb.py . <code
class="python">login()</code> calls <code
class="python">getRootObject()</code> directly, after that each step is
executed as a callback when the previous step completes.</p>

<pre>
getRootObject():
 root.callRemote("login", credentials.username)
 challenger.callRemote("respond",
                       respond(challenge, credentials.password), client)
</pre>

<p>The client does <code class="python">reactor.connectTCP()</code> to connect to
the given host and port, and <code class="python">reactor.connectTCP()</code> to
retrieve the object named <code>root</code>. On
the server side, the <code>PBServerFactory</code> accepts the connection and
creates a wrapper around the <code>Portal</code> to handle the authentication.
The portal uses the checker registered to do a challenge/response stage,
and then asks the <code>Realm</code> that it wraps for a
<code>IPerspective</code>.</p>

<p>The client gives the <code>IPerspective</code> reference to the callback
that was attached to the <code>Deferred</code> that
<code>login()</code> returned, which brings us back up to the code
visible in <code>pb6client1.py</code>.</p>

<h2>Viewable</h2>

<p>Once you have <code>IPerspective</code> objects to represent users, the
<code class="API" base="twisted.spread.flavors">Viewable</code> class can
come into play. This class behaves a lot like <code>Referenceable</code>: it
turns into a <code>RemoteReference</code> when sent over the wire, and
certain methods can be invoked by the holder of that reference. However, the
methods that can be called have names that start with <code>view_</code>
instead of <code>remote_</code>, and those methods are always called with an
extra <code>perspective</code> argument:</p>

<pre class="python">
class Foo(pb.Viewable):
    def view_doFoo(self, perspective, arg1, arg2):
        pass
</pre>

<p>This is useful if you want to let multiple clients share a reference to
the same object. The <code>view_</code> methods can use the
<q>perspective</q> argument to figure out which client is calling them. This
gives them a way to do additional permission checks, do per-user accounting,
etc.</p>


<h2>A Larger Example</h2><a name="bigexample" />

<p>Now it's time to look more closely at the Go server described before.</p>

<p>To simplify the example, we will build a server that handles just a
single game. There are a variety of players who can participate in the game,
named Alice, Bob, etc (the usual suspects). Two of them log in, choose
sides, and begin to make moves.</p>

<p> We assume that the rules of the game are encapsulated into a
<code>GoGame</code> object, so we can focus on the code that handles the
remote players.</p>

<p>XXX: finish this section</p>


<p>That's the end of the tour. If you have any questions, the folks at the
welcome office will be more than happy to help. Don't forget to stop at the
gift store on your way out, and have a really nice day. Buh-bye now!</p>

</body> </html>
