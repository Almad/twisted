<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <title>New Cred: Authentication for the 24th Century</title>
  </head>
  <body>
    <h1>New Cred: Authentication for the 24th Century</h1>

    <h2>Old Cred</h2>
<p>Authentication in Twisted services comes from modules in the 'twisted.cred'
package.  The old API for authentication was complex, large, and did not handle
multiple types of authentication well.  The new API is much smaller and easier
to use, and hopefully will be widely adopted outside of the Twisted internals.
</p>

    <h2>The Portal</h2>
<p>This is the ineffable mystery at the core of login.  There is one 
concrete implementation of Portal, and no interface - it does a very 
simple task.  A Portal associates one (1) Realm with a collection of 
CredentialChecker instances.  (More on those later.)</p>

<p>The closest analogue of this in Old Cred was the Authorizer.</p>

<p>If you are writing a protocol that needs to authenticate against 
something, you will need a reference to a Portal, and to nothing else.  
This has only 2 methods -</p>

	<code class="API">login(credentials, mind, *interfaces)</code>

<p>The docstring is quite expansive (see twisted.cred.portal), but in 
brief, this is what you call when you need to call in order to connect 
a user to the system.  The result is a deferred which fires a tuple of:</p>
    <ul>
	<li>interface (which was one of the interfaces passed in the *interfaces 
tuple)</li>
	<li>an object that implements that interface (an Aspect of an Avatar)</li>
    <li>logout, a 0-argument callable which disconnects the connection that was 
established by this call to login</li>
    </ul>

	<code class="API">registerChecker(checker, *credentialInterfaces)</code>

<p>which adds a CredentialChecker to the portal.</p>

    <h2>The Mind</h2>
<p>Masters of Perspective Broker already know this object as the ill-named 
<q>client object</q>.  There is no <q>mind</q> class, or even interface, but it 
is an object which serves an important role - any notifications which 
are to be relayed to an authenticated client are passed through a 
'mind'.</p>

<p>The name may seem rather unusual, but considering that a Mind is 
representative of the entity on the <q>other end</q> of a network connection
that is both receiving updates and issuing commands, I believe it is 
appropriate.</p>

<p>Although many protocols will not use this, it serves an important role. 
  It is provided as an argument both to the Portal and to the Realm, 
although a CredentialChecker should interact with a client program 
exclusively through a Credentials instance.</p>

<p>Unlike the original Perspective Broker <q>client object</q>, a Mind's 
implementation is most often dictated by the protocol that is 
connecting rather than the Realm.  A Realm which requires a particular 
interface to issue notifications will need to wrap the Protocol's mind 
implementation with an adapter in order to get one that conforms to its 
expected interface - however, Perspective Broker will likely continue 
to use the model where the client object has a pre-specified remote 
interface.</p>

<p>(If you don't quite understand this, it's fine.  It's hard to explain, 
and it's not used in simple usages of cred, so feel free to pass None 
until you find yourself requiring something like this.)</p>

    <h2>The CredentialChecker</h2>
<p>This is an object which resolves some Credentials to an avatar ID.  
Some examples of CredentialChecker implementations would be: 
InMemoryUsernamePassword, ApacheStyleHTAccessFile, 
UNIXPasswordDatabase, SSHPublicKeyDatabase.  A credential checker 
stipulates some requirements of the credentials it can check by 
specifying a credentialInterfaces attribute, which is a list of 
interfaces.  Credentials passed to its requestAvatarId method must 
implement one of those interfaces.</p>

<p>For the most part, these things will just check usernames and passwords 
and produce the username as the result, but hopefully we will be seeing 
some public-key, challenge-response, and certificate based credential 
checker mechanisms soon.</p>

<p>A credential checker should raise an error if it cannot authenticate 
the user, and return '' for anonymous access.</p>

    <h2>The Credentials</h2>
<p>Oddly enough, this represents some credentials that the user presents.  
Usually this will just be a small static blob of data, but in some 
cases it will actually be an object connected to a network protocol.  
For example, a username/password pair is static, but a 
challenge/response server is an active state-machine that will require 
several method calls in order to determine a result.</p>

    <h2>The Realm</h2>
<p>A realm is an interface which connects your universe of <q>business 
objects</q> to the authentication system.  This is similar to the Old Cred 
    <q>Service</q>, but the name <q>Service</q> will be phased out when referring to 
cred - another planned refactoring is to move 
twisted.internet.app.ApplicationService into its own module and more 
heavily emphasize its use in start-up and shut-down.</p>

IRealm is another one-method interface:

	<code class="API">requestAvatar(avatarId, mind, *interfaces)</code>

<p>This method will typically be called from 'Portal.login'.  The avatarId 
is the one returned by a CredentialChecker.</p>

<p>The important thing to realize about this method is that if it is being 
called, _the user has already authenticated_.  Therefore, if possible, 
the Realm should create a new user if one does not already exist 
whenever possible.  Of course, sometimes this will be impossible 
without more information, and that is the case that the interfaces 
argument is for.</p>

<p>Some protocols can only accept a fixed set of interfaces.  However, 
others (most notably PB) can deal with more arbitrary data being 
returned.  An online game may call Portal.login with:</p>

<pre class="python">
    login(PBChallengeResponse(...), clientSideThingy,
           IServerPlayerInWorld, IUserChooser, ICharacterCreationThing)
</pre>

<p>This specifies that the client would most prefer a player in the world, 
but, failing that, a UserChooser (selection interface for a second step 
to get a PlayerInWorld) or a CharacterCreationThing (interface to 
create a new character in the world before returning it) would be 
acceptable.</p>

<p>Since requestAvatar should be called from a Deferred callback, it may 
return a Deferred or a synchronous result.</p>

<p>At the moment, there is only an interface for the Realm.  However, it 
is expected that a utility class will be written in the near future to 
facilitate log-in methods, a re-directing method similar to 
<q>Perspective.attached</q> for Avatars, and at least somewhat automated 
compositing of Realms.  However, in writing the code for cred and 
guard, there has been no need for such a thing yet.</p>

    <h2>The Avatar</h2>
<p>This object has the dubious distinction of appearing nowhere in the 
code; in fact, very few things will ever touch an actual Avatar, and it 
is not clear that it will have an interface.  However, _aspects_ of an 
avatar are returned in deferreds from the above methods, which is to 
say, things that implement particular interfaces which communicate with 
various protocols that may access your Realm.</p>

<p>This is (hopefully, obviously) similar to a 'Perspective'.  However, an 
Avatar separates 2 concerns which were muddied previously - _access_ to 
a realm and _storage of user data_ within a realm.  The avatar itself 
stores the data, and the aspects interface to it.  The avatar itself 
may of course implement its own aspects, but it is suggested in most 
cases to register adapters that do this.  (Perspective Broker will keep 
its name, because the Avatar Aspect that communicates with the remote 
object protocol will still be called a Perspective.)</p>

<h2>TODO (hopefully) short example of using new cred to authenticate</h2>

<h2>TODO example of writing a new kind of authentication</h2>
</body></html>

