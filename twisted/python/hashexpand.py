#!/usr/bin/env python
#
#  Copyright (c) 2000 Autonomous Zone Industries
#  Copyright (c) 2002 Bryce "Zooko" Wilcox-O'Hearn
#  mailto:zooko@zooko.com
#  This file is licensed under the
#    GNU Lesser General Public License v2.1.
#    See the file COPYING or visit http://www.gnu.org/ for details.
#
# The most actively maintained copy of this file is in the pyutil project:
# http://sourceforge.net/projects/pyutil

# Python standard library modules
import sha

# pyutil modules
from compat import strpopL

class HashExpander:
    """
    Provides a cryptographically strong pseudo-random number generator based on SHA1.  Hopefully this means that as long as SHA1 is collision free and irreversible then no attacker will be able to predict any bit of output that he hasn't seen, given that he doesn't know anything about the seed and given that he can see as many bits of output as he desires except for the bit that he is trying to predict.
    Further it is hoped that an attacker will not even be able to determine whether a given stream of random bytes was generated by this PRNG or by flipping a coin repeatedly.
    # XXX Note that collision-freeness and irreversibility isn't sufficient for all of these desiderata.  I think that you would have to add "pseudorandom" to your assumptions...  I intend to research this someday...  --Zooko 2002-05-06
    The safety of this technique has not been verified by a Real Cryptographer.
    """
    def __init__(self, seed):
        self.seed(seed)

    def seed(self, seed):
        """
        Make sure that an attacker cannot guess `seed' with a non-negligible chance of success.  (The precondition doesn't guarantee this, of course -- it is just to help you notice if you've passed the wrong variable by mistake.)

        @precondition seed must be long enough.: len(seed) >= 10: "seed: %s" % std.hr(seed)
        """
        assert len(seed) >= 10, "precondition: seed must be long enough." + " -- " + "seed: %s" % std.hr(seed)

        self._seed = seed
        self._avail = ""
        self._counter = 0

    def get(self, bytes):
        bytesleft = bytes

        res = "" ## !! XX Note: this could be faster...  -Zooko 2000/07/03

        while bytesleft > 0:
            if len(self._avail) == 0:
                h = sha.new('(5:type:X:Mnet hash expansion v1;10:algorithm:5:SHA1;6:value:(')
                seedlen = len(self._seed)
                seedlenstr = strpopL(seedlen)
                h.update(seedlenstr)
                h.update(':')
                h.update(self._seed)
                counterstr = strpopL(self._counter)
                counterstrlen = len(counterstr)
                counterstrlenstr = strpopL(counterstrlen)
                h.update(counterstrlenstr)
                h.update(':')
                h.update(counterstr)
                h.update('))')
                self._avail = h.digest()
                try:
                    self._counter = self._counter + 1
                except OverflowError:
                    self._counter = self._counter + 1L

            numb = min(len(self._avail), bytesleft)
        
            chunk = self._avail[:numb]
            self._avail = self._avail[numb:]

            res = res + chunk
            assert len(chunk) == numb
            
            bytesleft = bytesleft - numb

        assert len(res) == bytes

        return res

def hashexpand(inpstr, expbytes):
    return HashExpander(inpstr).get(expbytes)
