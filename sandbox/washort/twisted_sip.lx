# -*- test-case-name: quotient.test.test_twisted_sip -*-

# Twisted, the Framework of Your Internet
# Copyright (C) 2001 Matthew W. Lefkowitz
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

"""Session Initiation Protocol.
Documented in RFC 3261.

TODO:
* Separation of transaction layer from proxy.
* TCP support.
* SSL/TLS support.
* Multicast support.
"""

limport twisted.python.syntax 
setlang syntax.twisted

# system imports
#XXX make multiple modules on a single import line work
import socket
import random
import md5
import sys
import weakref
import sets
import urllib

# twisted imports
from twisted.python import log, util
from twisted.internet import protocol, defer, reactor, abstract
from twisted.python.components import Interface
from twisted.names import client

from twisted.cred import credentials
from twisted.cred.error import UnauthorizedLogin

# sibling imports
from twisted.protocols import basic

#XXX cheating
from atop.credup import Preauthenticated

debuggingEnabled=1

def debug(*args):
    if debuggingEnabled:
        log.debug(*args)

PORT = 5060
DEFAULT_REGISTRATION_LIFETIME = 3600

# SIP headers have short forms
shortHeaders = {"call-id": "i", "contact": "m", "content-encoding": "e", "content-length": "l", "content-type": "c", "from": "f", "subject": "s", "to": "t", "via": "v"}


longHeaders = {}
for k, v in shortHeaders.items():
    longHeaders[v] = k
del k, v

statusCodes = {
    100: "Trying",
    180: "Ringing",
    181: "Call Is Being Forwarded",
    182: "Queued",

    200: "OK",

    300: "Multiple Choices",
    301: "Moved Permanently",
    302: "Moved Temporarily",
    303: "See Other",
    305: "Use Proxy",
    380: "Alternative Service",

    400: "Bad Request",
    401: "Unauthorized",
    402: "Payment Required",
    403: "Forbidden",
    404: "Not Found",
    406: "Not Acceptable",
    407: "Proxy Authentication Required",
    408: "Request Timeout",
    409: "Conflict",
    410: "Gone",
    411: "Length Required",
    413: "Request Entity Too Large",
    414: "Request-URI Too Large",
    415: "Unsupported Media Type",
    420: "Bad Extension",
    480: "Temporarily not available",
    481: "Call Leg/Transaction Does Not Exist",
    482: "Loop Detected",
    483: "Too Many Hops",
    484: "Address Incomplete",
    485: "Ambiguous",
    486: "Busy Here",
    487: "Request Cancelled",

    500: "Internal Server Error",
    501: "Not Implemented",
    502: "Bad Gateway",
    503: "Service Unavailable",
    504: "Gateway Time-out",
    505: "SIP Version not supported",

    600: "Busy Everywhere",
    603: "Decline",
    604: "Does not exist anywhere",
    606: "Not Acceptable"}
# some headers change case strangely.
specialCases = {
    'cseq': 'CSeq',
    'call-id': 'Call-ID',
    'www-authenticate': 'WWW-Authenticate',
    'proxy-authenticate': 'Proxy-Authenticate',
    'proxy-authorization':'Proxy-Authorization',
    'record-route':'Record-Route'}

def unq(s):
    if s[0] == '"' and s[-1] == '"':
        return s[1:-1]
    return s

def DigestCalcHA1(
    pszAlg,
    pszUserName,
    pszRealm,
    pszPassword,
    pszNonce,
    pszCNonce):
    m = md5.md5()
    m.update(pszUserName)
    m.update(":")
    m.update(pszRealm)
    m.update(":")
    m.update(pszPassword)
    HA1 = m.digest()
    if pszAlg == "md5-sess":
        m = md5.md5()
        m.update(HA1)
        m.update(":")
        m.update(pszNonce)
        m.update(":")
        m.update(pszCNonce)
        HA1 = m.digest()
    return HA1.encode('hex')

def DigestCalcResponse(
    HA1,
    pszNonce,
    pszNonceCount,
    pszCNonce,
    pszQop,
    pszMethod,
    pszDigestUri,
    pszHEntity):
    m = md5.md5()
    m.update(pszMethod)
    m.update(":")
    m.update(pszDigestUri)
    if pszQop == "auth-int":
        m.update(":")
        m.update(pszHEntity)
    HA2 = m.digest().encode('hex')

    m = md5.md5()
    m.update(HA1)
    m.update(":")
    m.update(pszNonce)
    m.update(":")
    if pszNonceCount and pszCNonce: # pszQop:
        m.update(pszNonceCount)
        m.update(":")
        m.update(pszCNonce)
        m.update(":")
        m.update(pszQop)
        m.update(":")
    m.update(HA2)
    hash = m.digest().encode('hex')
    return hash

class Via:
    """A SIP Via header."""

    def __init__(self, host, port=PORT, transport="UDP", ttl=None, hidden=False,
                 received=None, rport=None, branch=None, maddr=None):
        self.transport = transport
        self.host = host
        self.port = port
        self.ttl = ttl
        self.hidden = hidden
        self.received = received
        self.rport = rport
        self.branch = branch
        self.maddr = maddr

    def toString(self):
        s = "SIP/2.0/%s %s:%s" % (self.transport, self.host, self.port)
        if self.hidden:
            s += ";hidden"
        for n in "ttl", "branch", "maddr", "received", "rport":
            value = getattr(self, n)
            if value == True:
                s += ";" + n
            elif value != None:
                s += ";%s=%s" % (n, value)
        return s


def parseViaHeader(value):
    """Parse a Via header, returning Via class instance."""
    try:
        parts = value.split(";")
        sent, params = parts[0], parts[1:]
        protocolinfo, by = sent.split(" ", 1)
        result = {}
        pname, pversion, transport = protocolinfo.split("/")
        if pname != "SIP" or pversion != "2.0":
            raise SIPError(400, "wrong protocol or version: %r" % value)
        result["transport"] = transport
        if ":" in by:
            host, port = by.split(":")
            result["port"] = int(port)
            result["host"] = host
        else:
            result["host"] = by
        for p in params:
            # it's the comment-striping dance!
            p = p.strip().split(" ", 1)
            if len(p) == 1:
                p, comment = p[0], ""
            else:
                p, comment = p
            if p == "hidden":
                result["hidden"] = True
                continue
            parts = p.split("=", 1)
            if len(parts) == 1:
                name, value = parts[0], True
            else:
                name, value = parts
                if name in ("rport", "ttl"):
                    value = int(value)
            result[name] = value
        return Via(**result)
    except:
        raise SIPError(400)

class URL:
    """A SIP URL."""

    def __init__(self, host, username=None, password=None, port=None,
                 transport=None, usertype=None, method=None,
                 ttl=None, maddr=None, tag=None, other=None, headers=None):
        self.username = username
        self.host = host
        self.password = password
        self.port = port
        self.transport = transport
        self.usertype = usertype
        self.method = method
        self.tag = tag
        self.ttl = ttl
        self.maddr = maddr
        if other == None:
            self.other = {}
        else:
            self.other = other
        if headers == None:
            self.headers = {}
        else:
            self.headers = headers

    def toCredString(self):
        return '%s@%s' % (self.username, self.host)

    def toString(self):
        l = []; w = l.append
        w("sip:")
        if self.username != None:
            w(urllib.quote(self.username))
            if self.password != None:
                w(":%s" % (urllib.quote(self.password)))
            w("@")
        w(self.host)
        if self.port != None:
            w(":%d" % self.port)
        if self.usertype != None:
            w(";user=%s" % self.usertype)
        for n in ("transport", "ttl", "maddr", "method", "tag"):
            v = getattr(self, n)
            if v != None:
                w(";%s=%s" % (urllib.quote(n), urllib.quote(v)))
        for k, v in self.other.iteritems():
            if v:
                w(";%s=%s" % (urllib.quote(k), urllib.quote(v)))
            else:
                w(";%s" % k)
        if self.headers:
            w("?")
            w("&".join([("%s=%s" % (specialCases.get(h) or urllib.quote(h).capitalize(), urllib.quote(v))) for (h, v) in self.headers.items()]))
        return "".join(l)

    def __str__(self):
        return self.toString()

    def __repr__(self):
        return '<sip.URL %s>' % self.toString()

    def __cmp__(self, other):
        return cmp(self.__dict__, other.__dict__)

    def __hash__(self):
        #I could include the other stuff but what's the point?
        #this is the most usual stuff and python is very kind to collisions
        return hash((self.host, self.username, self.port, tuple(self.headers.items())))

def parseURL(url, host=None, port=None):
    """Return string into URL object.

    URIs are of of form 'sip:user@example.com'.
    """
    d = {}
    if not url.startswith("sip:"):
        raise SIPError(416, "Unsupported URI scheme: " + url[:4])
    parts = url[4:].split(";")
    userdomain, params = parts[0], parts[1:]
    udparts = userdomain.split("@", 1)
    if len(udparts) == 2:
        userpass, hostport = udparts
        upparts = userpass.split(":", 1)
        if len(upparts) == 1:
            d["username"] = urllib.unquote(upparts[0])
        else:
            d["username"] = urllib.unquote(upparts[0])
            d["password"] = urllib.unquote(upparts[1])
    else:
        hostport = udparts[0]
    hpparts = hostport.split(":", 1)
    if len(hpparts) == 1:
        d["host"] = hpparts[0]
    else:
        d["host"] = hpparts[0]
        d["port"] = int(hpparts[1])
    if host != None:
        d["host"] = host
    if port != None:
        d["port"] = port
    for p in params:
        if p == params[-1] and "?" in p:
            d["headers"] = h = {}
            p, headers = p.split("?", 1)
            for header in headers.split("&"):
                k, v = header.split("=")
                h[urllib.unquote(k)] = urllib.unquote(v)
        nv = p.split("=", 1)
        if len(nv) == 1:
            d.setdefault("other", {})[urllib.unquote(p)] = ''
            continue
        name, value = map(urllib.unquote, nv)
        if name == "user":
            d["usertype"] = value
        elif name in ("transport", "ttl", "maddr", "method", "tag"):
            if name == "ttl":
                value = int(value)
            d[name] = value
        else:
            d.setdefault("other", {})[name] = value
    return URL(**d)


def cleanRequestURL(url):
    """Clean a URL from a Request line."""
    url.transport = None
    url.maddr = None
    url.ttl = None
    url.headers = {}


def parseAddress(address, host=None, port=None, clean=0):
    """Return (name, uri, params) for From/To/Contact header.

    @param clean: remove unnecessary info, usually for From and To headers.

    Although many headers such as From can contain any valid URI, even those
    with schemes other than 'sip', this function raises SIPError if the scheme
    is not 'sip' because the upper layers do not support it.
    """
    def splitParams(paramstring):
        params = {}
        paramstring = paramstring.strip()
        if paramstring:
            for l in paramstring.split(";"):
                if not l:
                    continue
                x = l.split("=")
                if len(x) > 1:
                    params[x[0]] = x[1]
                else:
                    params [x[0]] = ''
        return params
    address = address.strip()
    # simple 'sip:foo' case
    if not '<' in address:
        i = address.rfind(";tag=")
        if i > -1:

            params = splitParams(address[i:])
            address = address[:i]
        else:
            params = {}
        return "", parseURL(address, host=host, port=port), params
    params = {}
    name, url = address.split("<", 1)
    name = name.strip()
    if name.startswith('"'):
        name = name[1:]
    if name.endswith('"'):
        name = name[:-1]
    import re
    name = re.sub('\\\\(.)', '\\1', name)
    url, paramstring = url.split(">", 1)
    url = parseURL(url, host=host, port=port)
    params = splitParams(paramstring)
    if clean:
        # rfc 2543 6.21
        url.ttl = None
        url.headers = {}
        url.transport = None
        url.maddr = None
    return name.decode('utf8','replace'), url, params


class SIPError(Exception):
    def __init__(self, code, phrase=None):
        if phrase is None:
            phrase = statusCodes[code]
        Exception.__init__(self, "SIP error (%d): %s" % (code, phrase))
        self.code = code
        self.phrase = phrase

class SIPLookupError(SIPError):
    """An error raised specifically for SIP lookup errors.
    """
    def __init__(self, code=404, phrase=None):
        SIPError.__init__(self, code=code, phrase=phrase)

class RegistrationError(SIPError):
    """Registration was not possible."""

class ISIPEvent(Interface):
    "A log message concerning SIP"

class IAuthorizer(Interface):
    def getChallenge(self, peer):
        """Generate a challenge the client may respond to.

        @type peer: C{tuple}
        @param peer: The client's address

        @rtype: C{str}
        @return: The challenge string
        """

    def decode(self, response):
        """Create a credentials object from the given response.

        @type response: C{str}
        """



class BasicAuthorizer:
    """Authorizer for insecure Basic (base64-encoded plaintext) authentication.

    This form of authentication is broken and insecure.  Do not use it.
    """

    __implements__ = (IAuthorizer,)

    def getChallenge(self, peer):
        return None

    def decode(self, response):
        # At least one SIP client improperly pads its Base64 encoded messages
        for i in range(3):
            try:
                creds = (response + ('=' * i)).decode('base64')
            except:
                None
            else:
                break
        else:
            # Totally bogus
            raise SIPError(400)
        p = creds.split(':', 1)
        if len(p) == 2:
            return credentials.UsernamePassword(*p)
        raise SIPError(400)

class DigestedCredentials(credentials.UsernameHashedPassword):
    """Yet Another Simple Digest-MD5 authentication scheme"""

    def __init__(self, username, fields, challenges):
        self.username = username
        self.fields = fields
        self.challenges = challenges

    def checkPassword(self, password):
        method = 'REGISTER'
        response = self.fields.get('response')
        uri = self.fields.get('uri')
        nonce = self.fields.get('nonce')
        cnonce = self.fields.get('cnonce')
        nc = self.fields.get('nc')
        algo = self.fields.get('algorithm', 'MD5')
        qop = self.fields.get('qop', 'auth')
        opaque = self.fields.get('opaque')

        if opaque not in self.challenges:
            return False
        del self.challenges[opaque]

        user, domain = self.username.split('@', 1)
        if uri is None:
            uri = 'sip:' + domain

        expected = DigestCalcResponse(
            DigestCalcHA1(algo, user, domain, password, nonce, cnonce),
            nonce, nc, cnonce, qop, method, uri, None)

        return expected == response

class DigestAuthorizer:
    CHALLENGE_LIFETIME = 15

    __implements__ = (IAuthorizer,)

    def __init__(self):
        self.outstanding = {}

    def generateNonce(self):
        c = tuple([random.randrange(sys.maxint) for _ in range(3)])
        c = '%d%d%d' % c
        return c

    def generateOpaque(self):
        return str(random.randrange(sys.maxint))

    def getChallenge(self, peer):
        c = self.generateNonce()
        o = self.generateOpaque()
        self.outstanding[o] = c
        return ','.join((
            'nonce="%s"' % c,
            'opaque="%s"' % o,
            'qop="auth"',
            'algorithm="MD5"'))

    def decode(self, response):
        response = ' '.join(response.splitlines())
        parts = response.split(',')
        auth = dict([(k.strip(), unq(v.strip())) for (k, v) in [p.split('=', 1) for p in parts]])
        try:
            username = auth['username']
        except KeyError:
            raise SIPError(401)
        try:
            return DigestedCredentials(username, auth, self.outstanding)
        except:
            raise SIPError(400)

class Message:
    """A SIP message."""

    length = None

    def __init__(self, version):
        self.headers = util.OrderedDict() # map name to list of values
        self.body = ""
        self.finished = 0
        self.version = version

    def copy(self):
        c = Message(self.version)
        c.headers = self.headers.copy()
        c.body = self.body
        c.finished = self.finished
        return c

    def __eq__(self, other):
        return (other.__class__ == self.__class__
                and self.version == other.version
                and dict([(k,v) for k,v in self.headers.items() if v]) == dict([(k,v) for k,v in other.headers.items() if v])
                and self.body == other.body)

    def addHeader(self, name, value):
        name = name.lower()
        name = longHeaders.get(name, name)
        if name == "content-length":
            self.length = int(value)
        self.headers.setdefault(name,[]).append(value)

    def bodyDataReceived(self, data):
        self.body += data

    def creationFinished(self):
        if (self.length != None) and (self.length != len(self.body)):
            raise ValueError, "wrong body length"
        self.finished = 1

    def toString(self):
        s = "%s\r\n" % self._getHeaderLine()
        for n, vs in self.headers.items():
            for v in vs:
                s += "%s: %s\r\n" % (specialCases.get(n) or n.capitalize(), v)
        s += "\r\n"
        s += self.body
        return s

    def _getHeaderLine(self):
        raise NotImplementedError


class Request(Message):
    """A Request for a URI"""


    def __init__(self, method, uri, version="SIP/2.0"):
        Message.__init__(self, version)
        self.method = method
        if isinstance(uri, URL):
            self.uri = uri
        else:
            self.uri = parseURL(uri)
            cleanRequestURL(self.uri)

    def copy(self):
        c = Message.copy(self)
        c.__class__ = Request
        c.method = self.method
        c.uri = self.uri
        return c

    def __eq__(self, other):
        return Message.__eq__(self, other) and self.method == other.method and self.uri == other.uri

    def __repr__(self):
        return "<SIP Request %d:%s %s>" % (id(self), self.method, self.uri.toString())

    def _getHeaderLine(self):
        return "%s %s %s" % (self.method, self.uri.toString(), self.version)


class Response(Message):
    """A Response to a URI Request"""

    def __init__(self, code, phrase=None, version="SIP/2.0"):
        Message.__init__(self, version)
        self.code = code
        if phrase == None:
            phrase = statusCodes[code]
        self.phrase = phrase

    def __eq__(self, other):
        return Message.__eq__(self, other) and self.code == other.code

    def __repr__(self):
        return "<SIP Response %d:%s>" % (id(self), self.code)

    def _getHeaderLine(self):
        return "SIP/2.0 %s %s" % (self.code, self.phrase)

def splitMultiHeader(s):
    "Split a header on commas, ignoring commas in quotes and escaped quotes."
    headers = []
    last = 0
    quoted = False
    for i in xrange(len(s)):
        if s[i] == '"':
            quoted = ~quoted
            if i == 0: continue
            j = i-1
            while s[j] == '\\':
                quoted = ~quoted
                j = j-1
        if not quoted and s[i] == ',':
            headers.append(s[last:i])
            last = i+1
    headers.append(s[last:])
    return headers



class MessagesParser(basic.LineReceiver):
    """A SIP messages parser.

    Expects dataReceived, dataDone repeatedly,
    in that order. Shouldn't be connected to actual transport.
    """

    version = "SIP/2.0"
    acceptResponses = 1
    acceptRequests = 1
    state = "firstline" # or "headers", "body" or "invalid"
    multiheaders = ['accept','accept-encoding', 'accept-language', 'alert-info', 'allow', 'authentication-info', 'call-info',  'content-encoding', 'content-language', 'error-info', 'in-reply-to', 'proxy-require',  'require',  'supported', 'unsupported', 'via', 'warning']
    multiAddressHeaders = ['route', 'record-route', 'contact']
    debug = 0

    def __init__(self, messageReceivedCallback):
        self.messageReceived = messageReceivedCallback
        self.reset()

    def reset(self, remainingData=""):
        self.state = "firstline"
        self.length = None # body length
        self.bodyReceived = 0 # how much of the body we received
        self.message = None
        self.setLineMode(remainingData)

    def invalidMessage(self):
        self.dataDone()
        raise SIPError(400)

    def dataDone(self):
        # clear out any buffered data that may be hanging around
        self.clearLineBuffer()
        if self.state == "firstline":
            return
        if self.state != "body":
            self.reset()
            return
        if self.length == None:
            # no content-length header, so end of data signals message done
            self.messageDone()
        elif self.length < self.bodyReceived:
            # aborted in the middle
            self.reset()
        else:
            # we have enough data and message wasn't finished? something is wrong
            raise RuntimeError, "this should never happen"

    def dataReceived(self, data):
        try:
            basic.LineReceiver.dataReceived(self, data)
        except:
            log.err()
            self.invalidMessage()

    def handleFirstLine(self, line):
        """Expected to create self.message."""
        raise NotImplementedError

    def lineLengthExceeded(self, line):
        self.invalidMessage()

    def lineReceived(self, line):
        if self.state == "firstline":
            while line.startswith("\n") or line.startswith("\r"):
                line = line[1:]
            if not line:
                return
            try:
                a, b, c = line.split(" ", 2)
            except ValueError:
                self.invalidMessage()
                return
            if a == "SIP/2.0" and self.acceptResponses:
                # response
                try:
                    code = int(b)
                except ValueError:
                    self.invalidMessage()
                    return
                self.message = Response(code, c)
            elif c == "SIP/2.0" and self.acceptRequests:
                self.message = Request(a, b)
            else:
                self.invalidMessage()
                return
            self.state = "headers"
            self.prevline = None
            return
        else:
            assert self.state == "headers"
        if line:
            x = line.lstrip()
            if line != x:
                #leading whitespace: this is a continuation line.
                self.prevline += x
            else:
                #new header
                if self.prevline:
                    try:
                        self.processHeaderLine(self.prevline)
                    except ValueError:
                        self.invalidMessage()
                        return
                self.prevline = line

        else:
            # CRLF, we now have message body until self.length bytes,
            # or if no length was given, until there is no more data
            # from the connection sending us data.
            self.state = "body"
            try:
                self.processHeaderLine(self.prevline)
            except ValueError:
                self.invalidMessage()
                return
            if self.length == 0:
                self.messageDone()
                return
            self.setRawMode()

    def processHeaderLine(self, line):
        name, value = line.split(":", 1)
        name, value = name.rstrip().lower(), value.lstrip()

        if name in self.multiheaders:
            multi = value.split(',')
            if multi:
                for v in multi:
                    self.message.addHeader(name, v)
            else:
                self.message.addHeader(v)
        elif name in self.multiAddressHeaders:
            for val in splitMultiHeader(value):
                self.message.addHeader(name, val)
        else:
            self.message.addHeader(name, value)
        if name.lower() == "content-length":
            self.length = int(value.lstrip())

    def messageDone(self, remainingData=""):
        assert self.state == "body"
        self.message.creationFinished()
        self.messageReceived(self.message)
        self.reset(remainingData)

    def rawDataReceived(self, data):
        if self.length == None:
            self.message.bodyDataReceived(data)
        else:
            dataLen = len(data)
            expectedLen = self.length - self.bodyReceived
            if dataLen > expectedLen:
                self.message.bodyDataReceived(data[:expectedLen])
                self.messageDone(data[expectedLen:])
                return
            else:
                self.bodyReceived += dataLen
                self.message.bodyDataReceived(data)
                if self.bodyReceived == self.length:
                    self.messageDone()


class Base(protocol.DatagramProtocol):
    """Base class for SIP clients and servers."""

    PORT = PORT
    debug = debuggingEnabled

    def __init__(self):
        self.messages = []
        self.parser = MessagesParser(self.addMessage)

    def addMessage(self, msg):
        self.messages.append(msg)

    def datagramReceived(self, data, addr):
        try:
            self.parser.dataReceived(data)
            self.parser.dataDone()
            try:
                for m in self.messages:
                    self._fixupNAT(m, addr)
                    if self.debug:
                        if isinstance(m, Request):
                            id = m.method
                        else:
                            id = m.code
                        log.msg("Received %r from %r" % (id, addr))
                    if isinstance(m, Request):
                        self.handle_request(m, addr)
                    else:
                        self.handle_response(m, addr)
            finally:
                del self.messages[:]
        except Exception, e:
            log.err()
            self._badRequest(addr, e)

    def _badRequest(self, addr, e):
        #request parsing failed, we're going to have to make stuff up
        if isinstance(e, SIPError):
            code = e.code
        else:
            code = 500
        r = Response(code)
        r.addHeader("to", "%s:%s" % (addr))
        self.sendMessage(URL(addr[0],port=addr[1]), r)

    def _fixupNAT(self, message, addr):
        srcHost, srcPort = addr
    # RFC 2543 6.40.2
        senderVia = parseViaHeader(message.headers["via"][0])
        if senderVia.host != srcHost:
            senderVia.received = srcHost
            if senderVia.port != srcPort:
                senderVia.rport = srcPort
            message.headers["via"][0] = senderVia.toString()
        elif senderVia.rport == True:
            senderVia.received = srcHost
            senderVia.rport = srcPort
            message.headers["via"][0] = senderVia.toString()

    def deliverResponse(self, responseMessage):
        """Deliver response.

        Destination is based on topmost Via header."""
        destVia = parseViaHeader(responseMessage.headers["via"][0])
        # XXX we don't do multicast yet
        host = destVia.received or destVia.host
        port = destVia.rport or destVia.port or self.PORT
        destAddr = URL(host=host, port=port)
        self.sendMessage(destAddr, responseMessage)

    sendRegistrationResponse = deliverResponse

    def responseFromRequest(self, code, request):
        """Create a response to a request message."""
        response = Response(code)
        for name in ("via", "to", "from", "call-id", "cseq"):
            response.headers[name] = request.headers.get(name, [])[:]

        return response
    localResponseFromRequest = responseFromRequest #surely this is not right

    def sendMessage(self, destURL, message):
        """Send a message.

        @param destURL: C{URL}. This should be a *physical* URL, not a logical one.
        @param message: The message to send.
        """
        if destURL.transport not in ("udp", None):
            raise RuntimeError, "only UDP currently supported"
        if self.debug:
            if isinstance(message, Request):
                id = message.method
            else:
                id = message.code
            log.msg("Sending %r to %r" % (id, destURL))
        self.transport.write(message.toString(), (destURL.host, destURL.port or self.PORT))

    def handle_request(self, message, addr):
        """Override to define behavior for requests received

        @type message: C{Message}
        @type addr: C{tuple}
        """
        raise NotImplementedError

    def handle_response(self, message, addr):
        """Override to define behavior for responses received.

        @type message: C{Message}
        @type addr: C{tuple}
        """
        raise NotImplementedError

    def lookupAddress(self, uri):
        """
        Look up the target set for this URI. If this URI is not for a domain
        we are responsible for, return it as the only target.
        """
        from atop.credup import NoSuchDomain, NoSuchUser
        when self.portal.login(Preauthenticated(uri.toCredString()), None, IContact) -> creds:
            (ifac, contact, logout) = creds
            when defer.maybeDeferred(contact.getRegistrationInfo) -> regs:
                return [i[0] for i in regs]
        except (NoSuchUser, NoSuchDomain, UnauthorizedLogin), e:
            if isinstance(e, (NoSuchDomain, UnauthorizedLogin)):
                return [uri]
            elif e == NoSuchUser:
                raise SIPLookupError(604)

        

class BaseProxy(Base):

    PORT = PORT

    def __init__(self, portal, hosts=None, port=PORT):
        """Create new instance.

        @param host: our hostname/IP as set in Via headers.
        @param port: our port as set in Via headers.
        """
        self.portal = portal
        self.hosts = hosts or [socket.getfqdn()]
        self.host = self.hosts[0]
        self.port = port
        Base.__init__(self)

    def getVia(self):
        """Return value of Via header for this proxy."""
        return Via(host=self.host, port=self.port)

    def handle_request_default(self, message, addr):
        """Default request handler.

        Default behaviour for OPTIONS and unknown methods for proxies
        is to forward message on to the client.

        Since at the moment we are stateless proxy, thats basically
        everything.
        """
        (srcHost, srcPort) = addr
        name, uri, tags = parseAddress(message.headers["to"][0], clean=1)
        fromname, fromuri, _ = parseAddress(message.headers["from"][0], clean=1)
        when self.lookupAddress(uri) -> targets:
            if len(targets) > 1:
                #XXX
                log.msg("SIP user with multiple targets, only handling the first. (%s)" % (targets,))
            target = targets[0]
            viaHeader = self.getVia()
            if viaHeader.toString() in message.headers["via"]:
                # must be a loop, so drop message
                log.msg("Dropping looped message.")
                return defer.fail(SIPError(482))

            message.headers["via"].insert(0, viaHeader.toString())
            when self._lookupURI(uri) -> addrs:
                when addrs[0] -> addr:
                    self.sendMessage(addr, message)
                except SIPError, error:
                    #why the do:? I don't really know. 
                    do: del message.headers["via"][0] # this'll be us
                    self.deliverResponse(self.localResponseFromRequest(error.code, message))

    def handle_response(self, message, addr):
        """Default response handler."""
        v = parseViaHeader(message.headers["via"][0])
        if v.port != self.port or v.host not in self.hosts:
            log.msg("Dropping incorrectly addressed message. Was addressed to %s:%s" % (v.host, v.port))
            return
        del message.headers["via"][0]
        if not message.headers["via"]:
            # this message is addressed to us
            self.gotResponse(message, addr)
            return
        self.deliverResponse(message)

    def gotResponse(self, message, addr):
        """Called with responses that are addressed at this server."""
        None

    def _lookupURI(self, userURI):
        """Leave this method: it is hooked by the tests.
        """
        if abstract.isIPAddress(userURI.host):
            # it is an IP not a hostname
            if not userURI.port:
                userURI.port = 5060
            return defer.succeed([defer.succeed(userURI)])
        else:
            if userURI.port is not None:
                return defer.succeed(self._resolveA([(userURI.host, userURI.port)]))
            when client.lookupService('_sip._udp.' + userURI.host) -> result:
                answers = result[0]
                if answers:
                    answers = [(a.payload.priority, str(a.payload.target), a.payload.port) for a in answers]
                    answers.sort()
                    results = []
                    for result in answers:
                        #OK I give up, this one needs "listfor" or something
                        priority, host, port = result
                        d = reactor.resolve(host)
                        results.append(d)
                        d.addCallback(URL, port=port)
                    return results
                else:
                    #just do an A lookup
                    when reactor.resolve(userURI.host) -> realaddr:
                        return [URL(realaddr, 5060)]



class IContact(Interface):
    """A user of a registrar or proxy"""

    def registerAddress(self, physicalURL, expiry):
        """Register the physical address of a logical URL.

        @return: Deferred of C{Registration} or failure with RegistrationError.
        """

    def unregisterAddress(self):
        """Unregister the physical address of a logical URL.

        @return: Deferred of C{Registration} or failure with RegistrationError.
        """

    def getRegistrationInfo(self):
        """Get registration info for logical URL.

        @return: Deferred of C{Registration} object or failure of SIPLookupError.
        """

    def callIncoming(self, name, callerURI, callerContact):
        """Record an incoming call with a user's name, the incoming
        SIP URI, and, if they are registered with our system, their
        caller IContact implementor.

        You may *decline* an incoming call by raising an exception in
        this method.  A SIPError is preferred.
        """

    def callOutgoing(self, name, calleeURI):
        """Record an outgoing call.
        """

T1 = 0.5
T2 = 4
T4 = 5
class ClientInviteTransaction(object):
    #17.1.1
    """
    The INVITE transaction consists of a three-way handshake.  The client
    transaction sends an INVITE, the server transaction sends responses,
    and the client transaction sends an ACK.
    """
    def set_state(self, state):
        if state is None:
            raise RuntimeError, "Null state prohibited! what were you thinking?"
        self._state = state
    def get_state(self):
        return self._state
    state = property(get_state, set_state)
    
    def __init__(self, st, proxy, invite, peerURL):
        self._state = None
        self.serverTransaction = st
        self.proxy = proxy
        self.request = invite
        self.peer = peerURL
        self.state = ClientCallingState(self)
        self.timerC = reactor.callLater(181, self.terminate) #timer C must be >3min

    def sendInvite(self):
        self.proxy.sendMessage(self.peer, self.request)

    def messageReceived(self, msg):
        # /responses/ are received over this connection. Requests come from the proxy.
        self.state = self.state.messageReceived(msg)
    def passMessage(self, msg):
        #Give this response to our server transaction.
        #To support UAs as well as proxies, this will have to change a bit
        #200s in INVITE transactions are ACKed by UAs but forwarded by proxies
        if msg.code == 100:
            #Provisional response. Don't give up yet.
            self.timerC.reset(181)
            return

        self.response = msg
        self.serverTransaction.messageProxied(msg)
        if 600 <= msg.code and msg.code < 700:
            #6xx requires killing all pending transactions as per 16.7.10
            self.proxy.globalCancel(self.serverTransaction)

    def timeout(self):
        self.passMessage(self.proxy.responseFromRequest(480,self.request))
        self.state = ClientInviteTerminatedState(self)

    def terminate(self):
        self.state = ClientInviteTerminatedState(self)


    def cancel(self):
        cancel = Request("CANCEL", self.request.uri)
        for hdr in ('via', 'from','to','call-id'):
            cancel.addHeader(hdr, self.request.headers[hdr][0])
        cancel.addHeader('max-forwards','70')
        cancel.addHeader('cseq', "%s CANCEL" % self.request.headers['cseq'][0].split(' ',1)[0])
        self.proxy.sendMessage(self.peer, cancel)

    def ack(self, msg):
        "Builds an ACK according to the rules in 17.1.1.3, RFC3261."
        ack = Request('ACK',self.request.uri)
        ack.headers['via'] = self.request.headers['via'][:1]
        for name in ("from", "call-id", 'route'):
            ack.headers[name] = self.request.headers.get(name, [])[:]
        ack.addHeader('cseq', "%s ACK" % self.request.headers['cseq'][0].split(' ',1)[0])
        ack.headers['to'] = msg.headers['to']
        ack.headers['max-forwards'] = ['70']

        self.proxy.sendMessage(self.peer, ack)

class ClientCallingState:
    #17.1.1.2
    """
    The initial state, "calling", MUST be entered when the TU
    initiates a new client transaction with an INVITE request.
    """
    def __init__(self, ct):
        debug("%s entering ClientCallingState" % ct.peer)
        self.ct = ct
        self.timerATries = 0
        self.sendInvite()
        self.timerB = reactor.callLater(64 * T1, self.ct.timeout)

    def messageReceived(self, msg):
        self.end()
        self.ct.passMessage(msg)

        if 100 <= msg.code and msg.code < 200:
            return ClientInviteProceedingState(self.ct)
        elif 200 <= msg.code and msg.code < 300:
            return ClientTerminatedState(self.ct)
        elif 300 <= msg.code and msg.code < 700:
            return ClientInviteCompletedState(self.ct, msg)

    def sendInvite(self):
        self.ct.sendInvite()
        self.timerATries += 1
        self.timerA = reactor.callLater(self.timerATries * T1, self.sendInvite)

    def end(self):
        if self.timerA.active():
            self.timerA.cancel()
        if self.timerB.active():
            self.timerB.cancel()


class ClientInviteProceedingState:

    def __init__(self, ct):
        debug("%s entering ClientInviteProceedingState" % ct.peer)
        self.ct = ct

    def messageReceived(self, msg):
        self.ct.passMessage(msg)
        if 100 <= msg.code and msg.code < 200:
            return self
        elif 200 <= msg.code and msg.code < 300:
            return ClientInviteTerminatedState(self.ct)
        elif 300 <= msg.code and msg.code < 700:
            return ClientInviteCompletedState(self.ct, msg)

    def end(self):
        None

class ClientInviteCompletedState:

    def __init__(self, ct, msg):
        debug("%s entering ClientInviteCompletedState" % ct.peer)
        self.ct = ct
        self.ct.ack(msg)
        self.timerD = reactor.callLater(32, self.ct.terminate)

    def messageReceived(self, msg):
        if msg.code >= 300:
            self.ct.ack(msg)
        return self

    def end(self):
        if self.timerD.active():
            self.timerD.cancel()

class ClientInviteTerminatedState:
    def __init__(self, ct):
        debug("%s entering ClientInviteTerminatedState" % ct.peer)
        ct.state.end()
        if ct.timerC.active():
            ct.timerC.cancel()
        ct.proxy.clientDied(ct)
        None
        
class ClientTransaction:

    def __init__(self, st, proxy, request, peerURL):
        self.serverTransaction = st
        self.proxy = proxy
        self.request = request
        self.peer = peerURL
        self.response = None
        self.state=ClientTryingState(self)

    def start(self):
        self.state = ClientTryingState(self)

    def messageReceived(self, msg):
        if isinstance(msg, Request) and msg.method == "CANCEL":
            response = self.proxy.localResponseFromRequest(200, msg)
            response.headers['via'] = msg.headers.get('via', [])
            self.respond(response)
            self.proxy.globalCancel(self)
            #self.terminate()
            return
        self.state = self.state.messageReceived(msg)

    def passMessage(self, msg):
        self.response = msg
        self.serverTransaction.messageProxied(msg)

    def terminate(self):
        self.state = ClientTerminatedState(self)

    def cancel(self):
        cancel = Request("CANCEL", self.request.uri)
        for hdr in ('from','to','call-id', 'via'):
            cancel.addHeader(hdr, self.request.headers[hdr][0])
        cancel.addHeader('max-forwards','70')
        cancel.addHeader('cseq', "%s CANCEL" % self.request.header['cseq'].split(' ',1)[0])
        self.proxy.sendMessage(self.peer, cancel)

class ClientTryingState:
    def __init__(self, ct):
        debug("%s entering ClientTryingState" % ct.peer)
        self.ct = ct
        self.timerETries = 0
        self.timerF = reactor.callLater(64*T1, self.ct.terminate)
        self.sendRequest()
        None
        
    def sendRequest(self):
        self.ct.proxy.sendMessage(self.ct.peer, self.ct.request)
        self.timerE = reactor.callLater(min((2**self.timerETries)*T1, T2), self.sendRequest)
        self.timerETries += 1

    def messageReceived(self, msg):
        self.end()
        self.ct.passMessage(msg)
        if msg.code >= 200:
            return ClientCompletedState(self.ct)
        else:
            return ClientProceedingState(self.ct)


    def end(self):
        if self.timerE.active():
            self.timerE.cancel()
        if self.timerF.active():
            self.timerF.cancel()

class ClientProceedingState:
    def __init__(self, ct):
        debug("%s entering ClientProceedingState" % ct.peer)
        self.ct = ct
        self.timerF = reactor.callLater(64*T1, self.ct.terminate)
        self.sendRequest()
        None
    def sendRequest(self):
        self.ct.proxy.sendMessage(self.ct.peer, self.ct.request)
        self.timerE = reactor.callLater(T2), self.sendRequest

    def messageReceived(self, msg):
        if msg.code < 200:
            return self
        else:
            self.end()
            return ClientCompletedState(self.ct)

    def end(self):
        if self.timerE.active():
            self.timerE.cancel()
        if self.timerF.active():
            self.timerF.cancel()


class ClientCompletedState:
    def __init__(self, ct):
        debug("%s entering ClientCompletedState" % ct.peer)
        self.ct = ct
        self.timerK = reactor.callLater(T4, self.ct.terminate)
        
    def messageReceived(self, msg):
        """
        The "Completed" state exists to buffer any additional response
        retransmissions that may be received (which is why the client
        transaction remains there only for unreliable transports).
        """

    def end(self):
        if self.timerK.active():
            self.timerK.cancel()

class ClientTerminatedState:
    def __init__(self, ct):
        debug("%s entering ClientTerminatedState" % ct.peer)
        ct.state.end()
        ct.serverTransaction.clientDied(ct)
        None
        
class ServerTryingState:
    def __init__(self, st):
        debug("%s entering ServerTryingState" % st.peer)
        self.st = st

    def messageReceived(self, msg):
        return self
    def messageProxied(self, msg):
        self.st.respond(msg)
        if 100 <= msg.code and msg.code < 200:
            return ServerProceedingState(self.st)
        else:
            return ServerCompletedState(self.st)

    def end(self):
        None

class ServerProceedingState:
    def __init__(self, st):
        debug("%s entering ServerProceedingState" % st.peer)
        self.st = st

    def messageReceived(self, msg):
        self.st.repeatLastResponse()
        return self
    def messageProxied(self, msg):
        self.st.respond(msg)
        if 100 <= msg.code and msg.code < 200:
            return self
        else:
            return ServerCompletedState(self.st)
    def end(self):
        None

class ServerCompletedState:
    def __init__(self, st):
        debug("%s entering ServerCompletedState" % st.peer)
        self.st = st
        self.timerJ = reactor.callLater(64*T1, self.st.terminate)
    def messageReceived(self, msg):
        self.st.repeatLastResponse()
        return self

    def messageProxied(self, msg):
        return self

    def end(self):
        if self.timerJ.active():
            self.timerJ.cancel()

class ServerTerminatedState:
    def __init__(self, st):
        debug("%s entering ServerTerminatedState" % st.peer)
        self.st = st
        st.state.end()
        st.proxy.serverTerminated(st)
        None
    def messageProxied(self, msg):
        #technically this should not be here
        #but i don't see how to deliver the final response before this
        #self.st.respond(msg)
        return self

class ServerTransaction:

    initialState = ServerTryingState

    def __init__(self, message, proxy, peerURL):
        self.message = message
        self.proxy = proxy
        self.peer = peerURL
        self.lastResponse = None
        self.transactions = []
        self.deadTransactions = []
        self.via = parseViaHeader(self.message.headers['via'][0])
        self.proxy.serverTransactions[self.via.branch] = self
        self.state = self.initialState(self)
        if message.method == 'REGISTER':
            self.proxy.handle_REGISTER_request(message, (self.peer.host, self.peer.port))
            return
        if message.method == 'BYE':
            self.proxy.untrackSession(message)
        if message.method == 'INVITE':
            when self.proxy.checkMessageAuthorization(message, self.peer) -> _:
                self.respond(self.proxy.localResponseFromRequest(100, message))
                self.proxy.deliverRequest(self, message)
            except SIPError, error:
                self.proxy.deliverResponse(self.proxy.localResponseFromRequest(error.code, message))
        elif message.method == 'OPTIONS' and (peerURL.username is None):
            self.respond(self.proxy.localResponseFromRequest(200, message))
        else:
            self.proxy.deliverRequest(self, message)
        None
        
    def respond(self, msg):
        self.lastResponse = msg
        self.proxy.sendMessage(self.peer, msg)

    def repeatLastResponse(self):
        self.proxy.sendMessage(self.peer, self.lastResponse)

    def messageReceived(self, msg):
        if msg.method == "CANCEL":
            self.respond(self.proxy.localResponseFromRequest(200, msg))
            self.proxy.globalCancel(self)
            return
        self.state = self.state.messageReceived(msg)


    def messageProxied(self, msg):
        self.state = self.state.messageProxied(msg)

    def terminate(self):
        self.state = ServerTerminatedState(self)

    def clientDied(self, ct):
        self.proxy.clientDied(ct)

    def chooseFinalResponse(self):
        #this is awful tricky and the RFC doesn't give hard and fast rules.
        cts = [(ct.response.code, ct) for ct in self.deadTransactions if ct.response]
        if not cts:
            self.messageProxied(self.proxy.localResponseFromRequest(408, self.message))
            return
        cts.sort()
        for code, ct in cts:
            if code >= 600:
                self.messageProxied(ct.response)
                return
        if cts[0][0] < 300:
            self.messageProxied(cts[0][1].response)
        else:
            if len(cts) > 1:
                log.msg("exciting SIP response set: %s" % ([x[0] for x in cts],))
                #this should pick out less final responses (like 407s)
                #and prefer them, but i am in a hurry
            self.messageProxied(cts[0][1].response)

class ServerInviteProceedingState:

    def __init__(self, st):
        self.st = st

    def messageReceived(self, msg):
        if msg.method == "INVITE":
            self.st.repeatLastResponse()
        return self
    def messageProxied(self, msg):
        self.st.respond(msg)
        if msg.code >= 600:
            self.st.proxy.globalCancel(self.st)
        if 100 < msg.code and msg.code < 200:
            return self
        elif 200 <= msg.code and msg.code < 300:
            #Bingo! INVITE succeeded, call now in progress.
            self.st.proxy.trackSession(msg)
            return ServerTerminatedState(self.st)
        elif 300 <= msg.code:
            return ServerInviteCompletedState(self.st)
        else:
            return self
    def end(self):
        None

class ServerInviteCompletedState:

    def __init__(self, st):
        self.st = st
        self.timerGTries = 0
        self.timerG = reactor.callLater(T1, self.sendResponse)
        self.timerH = reactor.callLater(64*T1,self.st.terminate)

    def sendResponse(self):
        self.st.repeatLastResponse()
        self.timerGTries += 1
        self.timerG = reactor.callLater(min((2**self.timerGTries)*T1, T2), self.sendResponse)

    def messageReceived(self, msg):
        if msg.method == "INVITE":
            self.st.repeatLastResponse()
            return self
        elif msg.method == "ACK":
            self.end()
            return ServerInviteConfirmedState(self.st)

    def messageProxied(self, msg):
        return self

    def end(self):
        if self.timerG.active():
            self.timerG.cancel()
        if self.timerH.active():
            self.timerH.cancel()


class ServerInviteConfirmedState:

    def __init__(self, st):
        self.st = st
        self.timerI = reactor.callLater(T4, self.st.terminate)

    def messageReceived(self, msg):
        return self
    def messageProxied(self, msg):
        return self

    def end(self):
        None


class ServerInviteTransaction(ServerTransaction):
    initialState = ServerInviteProceedingState


class RegistrationMixin:

    portal = None
    authorizers = {'digest': DigestAuthorizer()}


    def unauthorized(self, message, host, port):
        # log.msg("Failed registration attempt for %s from %s" % (message.headers.get('from'), message.headers.get('contact')))
        m = self.localResponseFromRequest(401, message)
        for (scheme, auth) in self.authorizers.iteritems():
            chal = auth.getChallenge((host, port))
            if chal is None:
                value = '%s realm="%s"' % (scheme.title(), self.host)
            else:
                value = '%s %s,realm="%s"' % (scheme.title(), chal, self.host)
            m.headers.setdefault('www-authenticate', []).append(value)
        self.sendRegistrationResponse(m)

    def handle_REGISTER_request(self, message, addr):
        (host, port) = addr
        name, toURL, params = parseAddress(message.headers["to"][0], clean=1)
        if not message.headers.has_key("authorization"):
            creds = credentials.UsernamePassword(toURL.toCredString(),'')
        else:
            parts = message.headers['authorization'][0].split(None, 1)
            a = self.authorizers.get(parts[0].lower())
            if a:
                creds = a.decode(parts[1])
                # IGNORE the authorization username - take that, SIP configuration UIs!!!
                creds.username = toURL.toCredString()
        when self.portal.login(creds, None, IContact) -> creds:
            i, a, l = creds

            self.register(a, message, host, port)
        except UnauthorizedLogin:
            self.unauthorized(message, host, port)

    def register(self, avatar, message, host, port):

        name, toURL, params = parseAddress(message.headers["to"][0], clean=1)
        contact = None
        if message.headers.has_key("contact"):
            contact = message.headers["contact"][0]

        expires = message.headers.get("expires", [None])[0]
        if expires == "0":
            if contact == "*":
                d = avatar <- unregisterAllAddresses()
            else:
                name, contactURL, params = parseAddress(contact, host=host, port=port)
                d = avatar <- unregisterAddress(contactURL)
            when d -> regdata:
                msg = self.localResponseFromRequest(200, message)
                #More backwards combatibility
                if len(regdata) == 1:
                    contactURL, expiry = regdata[0]
                    msg.addHeader("contact", contactURL.toString())
                    msg.addHeader("expires", str(expiry))
                else:
                    for contactURL, expiry in regdata:
                        msg.addHeader("contact", "%s;expires=%s" % (contactURL.toString(), expiry))
                self.sendRegistrationResponse(msg)
            except:
                None
            
        else:
            name, contactURL, params = parseAddress(contact, host=host, port=port)
            if contact is not None:
                if expires:
                    expiresInt = int(expires)
                else:
                    expiresInt = DEFAULT_REGISTRATION_LIFETIME
                d = avatar <- registerAddress(contactURL, expiresInt)
            else:
                d = avatar <- getRegistrationInfo()
            when d -> regdata:
                response = self.localResponseFromRequest(200, message)
                #for old times' sake I will send a separate Expires header if there is only one contact
                if len(regdata) == 1:
                    contactURL, expiry = regdata[0]
                    response.addHeader("contact", contactURL.toString())
                    response.addHeader("expires", str(expiry))
                else:
                    for contactURL, expiry in regdata:
                        response.addHeader("contact", "%s;expires=%s" % (contactURL.toString(), expiry))
                response.addHeader("content-length", "0")
                self.sendRegistrationResponse(response)
            except UnauthorizedLogin:
                self.unauthorized(message, host, port)

    def sendRegistrationResponse(self, msg):
        raise NotImplementedError

    def checkMessageAuthorization(self, message, addr): # this name sucks

        # this is a somewhat, uh, "compact" (some would say
        # obfuscated) representation of a series of unfortunate
        # events, so here is some prose to guide you through it:

        # First, we tell the caller (if they're registered with us) that
        # they're making a call, to give them the opportunity to record it on
        # the server.  they don't yet know whether their callee is registered
        # or not, and in fact it doesn't matter to them (they _made_ the call
        # without such information, after all).  A caller can potentially
        # cancel the call at this point by raising an exception but I can't
        # think of a reason to do that which isn't an error.

        # then, we tell the callee (if they're registered with us) that they're
        # receiving a call.  At this point, they may *decline* the call by
        # raising a SIPError of some kind in callIncoming.  This is the way
        # you'll implement call screening.  ( TODO: You *also* ought to be able
        # to implement a redirect on an incoming call by raising an appropriate
        # SIPError, but there is not currently a way to get the URL for the
        # redirect all the way back up the call chain. )

        # Before we relay this to the rest of the SIP logic, we make sure that
        # at least ONE of the participants was authorized to make or receive
        # this call through this server.  We don't want to proxy arbitrary
        # third-party INVITE requests.

        # Finally, we need to do the rest of the SIP logic, so we call through
        # to handle_request_default.  This will do its own call to .login() to
        # look up addresses when necessary.


        name, uri, tags = parseAddress(message.headers["to"][0], clean=1)
        fromname, fromuri, ignoredTags = parseAddress(message.headers["from"][0], clean=1)
        somebodyWasAuthorized = []

        def recordIt(oururi, theiruri, method, *extra):
            userid = Preauthenticated('%s@%s' % (oururi.username, oururi.host))
            when self.portal.login(userid, None, IContact) -> creds:
                iface, contact, logout = creds
                somebodyWasAuthorized.append(contact)
                getattr(contact,method)(name, theiruri, *extra)
                return contact
            except UnauthorizedLogin:
                None

        when recordIt(fromuri, uri, 'callOutgoing') -> caller:            
            when recordIt(uri, fromuri, 'callIncoming', caller) -> callee:
                if not somebodyWasAuthorized:
                    raise SIPError(401)
                return callee


class StatefulProxy(BaseProxy, RegistrationMixin):


    def responseFromRequest(self, code, request):
       """Create a response to a request message."""
       response = Response(code)
       response.headers['via'] = request.headers.get('via', [])[1:]
       for name in ("to", "from", "call-id", "cseq"):
           response.headers[name] = request.headers.get(name, [])[:]

       return response

    def localResponseFromRequest(self, code, request):
       """Create a response to a request message."""
       response = Response(code)
       for name in ("via", "to", "from", "call-id", "cseq"):
           response.headers[name] = request.headers.get(name, [])[:]

       return response


    def __init__(self, portal, hosts=None, port=PORT):
        BaseProxy.__init__(self, portal, hosts, port)
        self.recordroute = URL(host=self.host, port=self.port, other={'lr':''})
        self.clientTransactions = weakref.WeakValueDictionary()
        self.serverTransactions = {}
        self.sessions = {}

    def loopCheck(self, msg, addr):
        branch = self.computeVia(msg, msg.uri)
        for v in msg.headers['via']:
            via = parseViaHeader(v)
            if via.branch == branch:
                raise SIPError(482)

    def handle_request(self, msg, addr):
        if msg.headers.get('max-forwards',[None])[0] == '0':
            return

        self.loopCheck(msg, addr)

        if msg.uri == self.recordroute:
            self.copeWithStrictRouter(msg)

        if msg.headers.get('route',None):
            route = parseAddress(msg.headers['route'][0])[1]
            if route.host in self.hosts and (route.port or PORT) == self.port:
                del msg.headers['route'][0]

        via = parseViaHeader(msg.headers['via'][0])
        if via.branch:
            txnId = via.branch
        else:
            txnId = self.computeVia(msg, URL(addr[0], port=addr[1]))
        st = self.serverTransactions.get(txnId)
        if (st and via.host == st.via.host and via.port == st.via.port
            and (msg.method == st.message.method or (msg.method in ("ACK", "CANCEL") and st.message.method == "INVITE"))):
            st.messageReceived(msg)
        else:
            if msg.method == 'INVITE':
                t = ServerInviteTransaction(msg, self, URL(addr[0], port=addr[1]))
                self.serverTransactions[t] = []
            elif msg.method == 'ACK':
                return self.deliverRequest(None, msg)
            else:
                t = ServerTransaction(msg, self, URL(addr[0], port=addr[1]))
                self.serverTransactions[t] = []

    def sendRegistrationResponse(self, msg):
        via = parseViaHeader(msg.headers['via'][0])
        st = self.serverTransactions.get(via.branch)
        st.messageProxied(msg)

    def deliverRequest(self, serverTransaction, originalMsg):
        #This message has been processed by a transaction and approved for delivery.

        when self.lookupAddress(originalMsg.uri) -> addrs:

            for addr in addrs:
                #16.6.1
                msg = originalMsg.copy()
                #16.6.2
                msg.uri = addr
                #16.6.3
                if msg.headers.get('max-forwards'):
                    msg.headers['max-forwards'][0] = str(int(msg.headers['max-forwards'][0]) - 1)
                else:
                    msg.headers['max-forwards'] = ['70']
                #16.6.4
                if serverTransaction: #geez louise, this is going everywhere
                    msg.headers.setdefault('record-route', []).insert(0, self.recordroute.toString())
                #16.6.6
                if msg.headers.get('route', None):
                    if 'lr' not in parseAddress(msg.headers['route'][0])[1].other:
                        #more coping with strict routers
                        msg.headers['route'].append(msg.uri.toString())
                        msg.uri = parseAddress(msg.headers['route'].pop())[1]
                    else:
                        addr = parseAddress(msg.headers['route'][0])[1]


                #16.6.7
                when self._lookupURI(addr) -> targets:
                    for d in targets:
                        when d -> target:
                            #16.6.8
                            branch = self.computeVia(msg, target)
                            msg.headers['via'].insert(0, Via(host=self.host, port=self.port, branch=branch).toString())
                            if not serverTransaction:
                                self.sendMessage(target, msg)
                                return
                            #16.6.10
                            if msg.method == 'INVITE':
                                ct = ClientInviteTransaction(serverTransaction, self, msg, target)
                            else:
                                ct = ClientTransaction(serverTransaction, self, msg, target)
                            serverTransaction.transactions.append(ct)
                            self.clientTransactions[branch] = ct

        except SIPError, err:            
            self.deliverResponse(self.localResponseFromRequest(err.code, originalMsg))
            return None
        except:
            self.deliverResponse(self.localResponseFromRequest(500, originalMsg))
            return it #XXX nasty, need a clear way to re-raise
        


    def clientDied(self, ct):
        st = ct.serverTransaction
        cts = st.transactions
        deadct = cts.pop()
        st.deadTransactions.append(deadct)
        del self.clientTransactions[parseViaHeader(ct.request.headers['via'][0]).branch]
        if cts:
            cts[0].start()
        else:
            reactor.callLater(0, st.chooseFinalResponse) # cheesy way to get state transition finished first

    def serverTerminated(self, st):
        #somehow i think using the same dict with two different key
        #types is bad, but i was really confused when i started
        #writing this code (and hey the tests pass)
        del self.serverTransactions[st.via.branch]
        del self.serverTransactions[st]

    def globalCancel(self, st):
        for ct in st.transactions:
            ct.cancel()

    def copeWithStrictRouter(self, msg):
        "backwards compatibility with ancient sip proxies"
        msg.uri = msg.headers['route'].pop()

    def computeVia(self, msg, target):
        return "z9hG4bK"+ md5.new((parseAddress(msg.headers['to'][0])[2].get('tag','') +
                                   parseAddress(msg.headers['from'][0])[2].get('tag','') +
                                   msg.headers['call-id'][0] +
                                   target.toString() +
                                   msg.headers['via'][0] +
                                   msg.headers['cseq'][0].split(' ')[0])
                                  ).hexdigest()



    def handle_response(self, msg, addr):
        #16.7.1
        branch = parseViaHeader(msg.headers['via'][0]).branch
        if branch:
            ct = self.clientTransactions.get(branch)
        else:
            ct = None
        #16.7.3
        if ct and msg.headers['cseq'][0].endswith(ct.request.method):
            msg.headers['via'] = msg.headers['via'][1:]
            ct.messageReceived(msg)
        else:
            self.handle_stateless_response(msg, addr)

    def handle_stateless_response(self, msg, addr):
        debug("Stateless response: %s" % msg)
        BaseProxy.handle_response(self, msg, addr)

    def sessionID(self, msg):
        toHeader = parseAddress(msg.headers['to'][0])
        fromHeader = parseAddress(msg.headers['from'][0])
        return sets.ImmutableSet(((toHeader[2].get('tag',''), toHeader[1]), (fromHeader[2].get('tag',''), fromHeader[1])))

    def getSessionFor(self, msg):

        return self.sessions.get(self.sessionID(msg))

    def trackSession(self, msg):
        #Build a SIP session from this INVITE response.
        sid = self.sessionID(msg)
        debug("Tracking dialog: %s" % (list(sid),))
        self.sessions[sid] = SIPSession(msg)


    def untrackSession(self, msg):
        #Tear down a session based on this BYE.
        sid = self.sessionID(msg)
        debug("Untracking dialog: %s" % (list(sid),))
        self.sessions[sid].end()
        del self.sessions[sid]

class SIPSession:
    def __init__(self, msg):
        self.msg = msg

    def end(msg):
        None

class Proxy(BaseProxy):
    """SIP proxy."""

    def handle_request(self, message, addr):
        # send immediate 100/trying message before processing
        #self.deliverResponse(self.responseFromRequest(100, message))
        f = getattr(self, "handle_%s_request" % message.method, None)
        if f is None:
            f = self.handle_request_default
        d = defer.maybeDeferred(f, message, addr)
        def exceptBlock(err):
            if err.check(SIPError):
                errcode = err.value.code
                err = None
            else:
                errcode = 500
                log.err(err)
            self.deliverResponse(self.responseFromRequest(errcode, message))
            return err
        d.addErrback(exceptBlock)




class RegisterProxy(Proxy, RegistrationMixin):
    """A proxy that allows registration for a specific domain.

    Unregistered users won't be handled.
    """



    def __init__(self, *args, **kw):
        Proxy.__init__(self, *args, **kw)
        self.liveChallenges = {}

    def handle_ACK_request(self, message, addr):
        # XXX
        # ACKs are a client's way of indicating they got the last message
        # Responding to them is not a good idea.
        # However, we should keep track of terminal messages and re-transmit
        # if no ACK is received.
        None

    def handle_INVITE_request(self, message, addr):
        when self.checkMessageAuthorization(message, addr) -> callee:
            self.handle_request_default(message, addr)
