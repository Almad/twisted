-*- outline -*-

non-independent things left to do on newpb. These require deeper magic or
can not otherwise be done casually. Many of these involve fundamental
protocol issues, and therefore need to be decided sooner rather than later.


* change the method-call syntax to include an interfacename

Scope the method name to the interface. This implies (I think) one of two
things:

 callRemote() must take a RemoteInterface argument

 each RemoteReference handles just a single Interface

Probably the latter, maybe have the RR keep both default RI and a list of
all implemented ones, then adapting the RR to a new RI can be a simple copy
(and change of the default one) if the Referenceable knows about the RI.
Otherwise something on the local side will need to adapt one RI to another.
Need to handle reference-counting/DECREF properly for these shared RRs.

From glyph:

 callRemote(methname, **args) # searches RIs
 callRemoteInterface(remoteinterface, methname, **args) # single RI

 getRemoteURL(url, *interfaces)

 URL-RRefs should turn into the original Referenceable (in args/results)
  (map through the factory's table upon receipt)

 URL-RRefs will not survive round trips. leave reference exchange for later.
  (like def remote_foo(): return GlobalReference(self) )

 move method-invocation code into pb.Referenceable (or IReferenceable
 adapter). Continue using remote_ prefix for now, but make it a property of
 that code so it can change easily.
  <warner> ok, for today I'm just going to stick with remote_foo() as a
  low-budget decorator, so the current restrictions are 1: subclass
  pb.Referenceable, 2: implements() a RemoteInterface with method named "foo",
  3: implement a remote_foo method
  <warner> and #1 will probably go away within a week or two, to be replaced by
  #1a: subclass pb.Referenceable OR #1b: register an IReferenceable adapter

 try serializing with ISliceable first, then try IReferenceable. The
 IReferenceable adapter must implements() some RemoteInterfaces and gets
 serialized with a MyReferenceSlicer.

http://svn.twistedmatrix.com/cvs/trunk/pynfo/admin.py?view=markup&rev=44&root=pynfo

** use the methods of the RemoteInterface as the "method name"

 rr.callRemote(RIFoo.add, **args)

Nice and concise.


* create UnslicerRegistry, registerUnslicer

consider adopting the existing collection API (getChild, putChild) for this,
or maybe allow registerUnslicer() to take a callable which behaves kind of
like a twisted.web isLeaf=1 resource (stop walking the tree, give all index
tokens to the isLeaf=1 node)

also some APIs to get a list of everything in the registry

* use metaclass to auto-register RemoteCopy classes

** use metaclass to auto-register Unslicer classes

** and maybe Slicer classes too

 class FailureSlicer(slicer.BaseSlicer):
     classname = "twisted.python.failure.Failure"
     slicerForClasses = (failure.Failure,) # triggers auto-register

** various registry approaches

There are currently three kinds of registries used in banana/newpb:

 RemoteInterface <-> interface name
 class/type -> Slicer (-> opentype) -> Unslicer (-> class/type)
 Copyable subclass -> copyable-opentype -> RemoteCopy subclass

There are two basic approaches to representing the mappings that these
registries implement. The first is implicit, where the local objects are
subclassed from Sliceable or Copyable or RemoteInterface and have attributes
to define the wire-side strings that represent them. On the receiving side,
we make extensive use of metaclasses to perform automatic registration
(taking names from class attributes and mapping them to the factory or
RemoteInterface used to create the remote version).

The second approach is explicit, where pb.registerRemoteInterface,
pb.registerRemoteCopy, and pb.registerUnslicer are used to establish the
receiving-side mapping. There isn't a clean way to do it explicitly on the
sending side, since we already have instances whose classes can give us
whatever information we want.

The advantage of implicit is simplicity: no more questions about why my
pb.RemoteCopy is giving "not unserializable" errors. The mere act of
importing a module is enough to let PB create instances of its classes.

The advantage of doing it explicitly is to remind the user about the
existence of those maps, because the factory classes in the receiving map is
precisely equal to the user's exposure (from a security point of view). See
the E paper on secure-serialization for some useful concepts.

A disadvantage of implicit is that you can't quite be sure what, exactly,
you're exposed to: the registrations take place all over the place.

To make explicit not so painful, we can use quotient's .wsv files
(whitespace-separated values) which map from class to string and back again.
The file could list fully-qualified classname, wire-side string, and
receiving factory class on each line. The Broker (or rather the RootSlicer
and RootUnslicer) would be given a set of .wsv files to define their
mapping. It would get all the registrations at once (instead of having them
scattered about). They could also demand-load the receive-side factory
classes.

For now, go implicit. Put off the decision until we have some more
experience with using newpb.

* move from VocabSlicer sequence to ADDVOCAB/DELVOCAB tokens

Requires a .wantVocabString flag in the parser, which is kind of icky but
fixes the annoying asymmetry between set (vocab sequence) and get (VOCAB
token). Might want a CLEARVOCAB token too.

On second thought, this won't work. There isn't room for both a vocab number
and a variable-length string in a single token. It must be an open sequence.
However, it could be an add/del/set-vocab sequence, allowing the vocab to be
modified incrementally.

** VOCABize interface/method names

One possibility is to make a list of all strings used by all known
RemoteInterfaces and all their methods, then send it at broker connection
time as the initial vocab map. A better one (maybe) is to somehow track what
we send and add a word to the vocab once we've sent it more than three
times.

Maybe vocabize the pairs, as "ri/name1","ri/name2", etc, or maybe do them
separately. Should do some handwaving math to figure out which is better.

* nail down some useful schema syntaxes

This has two parts: parsing something like a __schema__ class attribute (see
the sketches in schema.xhtml) into a tree of FooConstraint objects, and
deciding how to retrieve schemas at runtime from things like the object being
serialized or the object being called from afar. To be most useful, the
syntax needs to mesh nicely (read "is identical to") things like formless and
(maybe?) atop or whatever has replaced the high-density highly-structured
save-to-disk scheme that twisted.world used to do.

Some lingering questions in this area:

 When an object has a remotely-invokable method, where does the appropriate
 MethodConstraint come from? Some possibilities:

  an attribute of the method itself: obj.method.__schema__

  from inside a __schema__ attribute of the object's class

  from inside a __schema__ attribute of an Interface (which?) that the object
  implements

 Likewise, when a caller holding a RemoteReference invokes a method on it, it
 would be nice to enforce a schema on the arguments they are sending to the
 far end ("be conservative in what you send"). Where should this schema come
 from? It is likely that the sender only knows an Interface for their
 RemoteReference.

 When PB determines that an object wants to be copied by value instead of by
 reference (pb.Copyable subclass, Copyable(obj), schema says so), where
 should it find a schema to define what exactly gets copied over? A class
 attribute of the object's class would make sense: most objects would do
 this, some could override jellyFor to get more control, and others could
 override something else to push a new Slicer on the stack and do streaming
 serialization. Whatever the approach, it needs to be paralleled by the
 receiving side's unjellyableRegistry.

* RemoteInterface instances should have an "RI-" prefix instead of "I-"

DONE

* merge my RemoteInterface syntax with zope.interface's

I hacked up a syntax for how method definitions are parsed in
RemoteInterface objects. That syntax isn't compatible with the one
zope.interface uses for local methods, so I just delete them from the
attribute dictionary to avoid causing z.i indigestion. It would be nice if
they were compatible so I didn't have to do that. This basically translates
into identifying the nifty extra flags (like priority classes, no-response)
that we want on these methods and finding a z.i-compatible way to implement
them. It also means thinking of SOAP/XML-RPC schemas and having a syntax
that can represent everything at once.


* use adapters to enable pass-by-reference or pass-by-value

It should be possible to pass a reference with variable forms:

 rr.callRemote("foo", 1, Reference(obj))
 rr.callRemote("bar", 2, Copy(obj))

This should probably adapt the object to IReferenceable or ICopyable, which
are like ISliceable except they can pass the object by reference or by
value. The slicing process should be:

 look up the type() in a table: this handles all basic types
 else adapt the object to ISliceable, use the result
 else raise an Unsliceable exception
  (and point the user to the docs on how to fix it)

The adapter returned by IReferenceable or ICopyable should implement
ISliceable, so no further adaptation will be done.

* remove 'copy' prefix from remotecopy banana type names?

<glyph> warner: did we ever finish our conversation on the usefulness of the
(copy foo blah) namespace rather than just (foo blah)?
<warner> glyph: no, I don't think we did
<glyph> warner: do you still have (copy foo blah)?
<warner> glyph: yup
<warner> so far, it seems to make some things easier
<warner> glyph: the sender can subclass pb.Copyable and not write any new
code, while the receiver can write an Unslicer and do a registerRemoteCopy
<warner> glyph: instead of the sender writing a whole slicer and the receiver
registering at the top-level
<glyph> warner: aah
<warner> glyph: although the fact that it's easier that way may be an artifact
of my sucky registration scheme
<glyph> warner: so the advantage is in avoiding registration of each new
unslicer token?
<glyph> warner: yes. I'm thinking that a metaclass will handily remove the
need for extra junk in the protocol ;)
<warner> well, the real reason is my phobia about namespace purity, of course
<glyph> warner: That's what the dots are for
<warner> but ease of dispatch is also important
<glyph> warner: I'm concerned about it because I consider my use of the same
idiom in the first version of PB to be a serious wart
* warner nods
<warner> I will put together a list of my reasoning
<glyph> warner: I think it's likely that PB implementors in other languages
are going to want to introduce new standard "builtin" types; our "builtins"
shouldn't be limited to python's provided data structures
<moshez> glyph: wait
<warner> ok
<moshez> glyph: are you talking of banana types
<moshez> glyph: or really PB
<warner> in which case (copy blah blah) is a non-builtin type, while
(type-foo) is a builtin type
<glyph> warner: plus, our namespaces are already quite well separated, I can
tell you I will never be declaring new types outside of quotient.* and
twisted.* :)
<warner> moshez: this is mostly banana (or what used to be jelly, really)
<glyph> warner: my inclination is to standardize by convention
<glyph> warner: *.* is a non-builtin type, [~.] is a builtin
<moshez> glyph: ?
<glyph> sorry [^.]*
<glyph> my regular expressions and shell globs are totally confused but you
know what I mean
<glyph> moshez: yes
<moshez> glyph: hrm
<saph_w> glyph: you're making crazy anime faces
<moshez> glyph: why do we need any non-Python builtin types
<glyph> moshez: because I want to destroy SOAP, and doing that means working
with people I don't like
<glyph> moshez: outside of python
<moshez> glyph: I meant, "what specific types"
<moshez> I'd appreciate a blog on that

* have Copyable/RemoteCopy default to __getstate__/__setstate__?

At the moment, the default implementations of getStateToCopy() and
setCopyableState() get and set __dict__ directly. Should the default instead
be to call __getstate__() or __setstate__()?

* make slicer/unslicers for pb.RemoteInterfaces

exarkun's use case requires these Interfaces to be passable by reference
(i.e. by name). It would also be interesting to let them be passed (and
requested!) by value, so you can ask a remote peer exactly what their
objects will respond to (the method names, the argument values, the return
value). This also requires that constraints be serializable.

do this, should be referenceable (round-trip should return the same object),
should use the same registration lookup that RemoteReference(interfacelist)
uses

* investigate decref/Referenceable race

Any object that includes some state when it is first sent across the wire
needs more thought. The far end could drop the last reference (at time t=1)
while a method is still pending that wants to send back the same object. If
the method finishes at time t=2 but the decref isn't received until t=3, the
object will be sent across the wire without the state, and the far end will
receive it for the "first" time without that associated state.

This kind of conserve-bandwidth optimization may be a bad idea. Or there
might be a reasonable way to deal with it (maybe request the state if it
wasn't sent and the recipient needs it, and delay delivery of the object
until the state arrives).

* sketch out how to implement glyph's crazy non-compressed sexpr encoding

* consider a smaller scope for OPEN-counter reference numbers

For newpb, we moved to implicit reference numbers (counting OPEN tags
instead of putting a number in the OPEN tag) because we didn't want to burn
so much bandwidth: it isn't feasible to predict whether your object will
need to be referenced in the future, so you always have to be prepared to
reference it, so we always burn the memory to keep track of them (generally
in a ScopedSlicer subclass). If we used explicit refids then we'd have to
burn the bandwidth too.

The sorta-problem is that these numbers will grow without bound as long as
the connection remains open. After a few hours of sending 100-byte objects
over a 100MB connection, you'll hit 1G-references and will have to start
sending them as LONGINT tokens, which is annoying and slightly verbose (say
3 or 4 bytes of number instead of 1 or 2). You never keep track of that many
actual objects, because the references do not outlive their parent
ScopedSlicer.

The fact that the references themselves are scoped to the ScopedSlicer
suggests that the reference numbers could be too. Each ScopedSlicer would
track the number of OPEN tokens emitted (actually the number of
slicerForObject calls made, except you'd want to use a different method to
make sure that children who return a Slicer themselves don't corrupt the
OPEN count).

This requires careful synchronization between the ScopedSlicers on one end
and the ScopedUnslicers on the other. I suspect it would be slightly
fragile.

One sorta-benefit would be that a somewhat human-readable sexpr-based
encoding would be even more human readable if the reference numbers stayed
small (you could visually correlate objects and references more easily). The
ScopedSlicer's open-parenthesis could be represented with a curly brace or
something, then the refNN number would refer to the NN'th left-paren from
the last left-brace. It would also make it clear that the recipient will not
care about objects outside that scope.
