<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>NewPB</title>
<style src="stylesheet-unprocessed.css"></style>
</head>

<body>
<h1>NewPB</h1>

<p>This document describes the new PB protocol. This is a layer on top of <a
href="banana.xhtml">Banana</a> which provides remote object access (method
invocation and instance transfer).</p>

<p>Fundamentally, PB is about one side keeping a
<code>RemoteReference</code> to the other side's <q>Referenceable</q>. The
Referenceable has some methods that can be invoked remotely: functionality
it is offering to remote callers. Those callers hold RemoteReferences which
point to it. The RemoteReference object offers a way to invoke those methods
(generally through the <code>callRemote</code> method).</p>

<p>There are plenty of other details, starting with how the RemoteReference
is obtained, and how arguments and return values are communicated.</p>

<p>For the purposes of this document, we will designate the side that holds
the actual <code>Referenceable</code> object as <q>local</q>, and the side
that holds the proxy <code>RemoteReference</code> object as <q>remote</q>.
This distinction is only meaningful with respect to a single
RemoteReference/Referenceable pair. One program may hold Referenceable
<q>A</q> and RemoteReference <q>B</q>, paired with another that holds
RemoteReference <q>A</q> and Referenceable <q>B</q>. Once initialization is
complete, PB is a symmetric protocol.</p>

<p>It is helpful to think of PB as providing a wire or pipe that connects
two programs. Objects are put into this pipe at one end, and something
related to the object comes out the other end. These two objects are said to
correspond to each other. Basic types (like lists and dictionaries) are
handled by Banana, but more complex types (like instances) are treated
specially, so that most of the time there is a <q>native</q> form (as
present on the local side) that goes into the pipe, and a remote form that
comes out.</p>

<h2>Initialization</h2>

<p>The PB session begins with some feature negotiation and (generally) the
receipt of a VocabularyDict. Usually this takes place over an interactive
transport, like a TCP connection, but newpb can also be used in a more
batched message-oriented mode, as long as both the creator of the method
call request and its eventual consumer are in agreement about their shared
state (at least, this is the intention.. there are still pieces that need to
be implemented to make this possible).</p>

<p>The local side keeps a table which provides a bidirectional mapping
between <code>Referenceable</code> objects and a connection-local
<q>object-ID</q> number. This table begins with a single object called the
<q>Root</q>, which is implicitly given ID number 0. Everything else is
bootstrapped through this object. For the typical PB Broker, this root
object performs cred authentication and returns other Referenceables as the
cred Avatar.</p>

<p>The remote side has a collection of <code>RemoteReference</code> objects,
each of which knows the object-ID of the corresponding Referenceable, as
well as the Broker which provides the connection to the other Broker. The
remote side must do reference-tracking of these RemoteReferences, because as
long as it remains alive, the local-side Broker must maintain a reference to
the original Referenceable.</p>

<h2>Method Calls</h2>

<p>The remote side invokes a remote method by calling
<code>ref.callRemote()</code> on its RemoteReference. This starts by
validating the method name and arguments against a <q>Schema</q> (described
below). It then creates a new Request object which will live until the
method call has either completed successfully or failed due to an exception
(including the connection being lost).</p>

<p>It then sends a <code>call</code> banana sequence over the wire. This
sequence indicates the request ID (used to match the request with the
resulting <code>answer</code> or <code>error</code> response), the object ID
of the Referenceable being targeted, a string to indicate the name of the
method being invoked, and the arguments to be passed into the method.</p>

<p>All arguments are passed by name (i.e. keyword arguments instead of
positional parameters). Each argument is subject to the <q>argument
transformation</q> described below.</p>

<p>The local side receives the <code>call</code> sequence, uses the
object-ID to look up the Referenceable, finds the desired method, then
applies the method's schema to the incoming arguments. If they are
acceptable, it invokes the method. A normal return value it sent back
immediately in an <code>answer</code> sequence. If the method returns a
Deferred, the answer will be sent back when the Deferred fires. If the
method raises an exception (or the Deferred does an errback), the resulting
Failure is sent back in a <code>error</code> sequence. Both the
<code>answer</code> and the <code>error</code> start with the request-ID so
they can be used to complete the Request object waiting on the remote
side.</p>

<h2>Argument Transformation</h2>

<p>To understand this section, it may be useful to review the <a
href="banana.xhtml">Banana</a> documentation on serializing object graphs.
Also note that method arguments and method return values are handled
identically.</p>

<p>Basic types (lists, tuples, dictionaries) are serialized and unserialized
as you would expect: the resulting object would (if it existed in the
sender's address space) compare as equal (but of course not
<q>identical</q>, because the objects will exist at different memory
locations).</p>

<h3>Shared References, Serialization Scope</h3>

<p>Shared references to the same object are handled correctly. Banana is
responsible for noticing that a sharable object has been serialized before
(or at least has begun serialization) and inserts reference markers so that
the object graph can be reconstructed. This introduces the concept of
serialization scope: the boundaries beyond which shared references are not
maintained.</p>

<p>For PB, serialization is scoped to the method call. If an object is
referenced by two arguments to the same method call, that method will see
two references to the same object. If those arguments are containers of some
form, which (eventually) hold a reference to the same object, the object
graph will be preserved. For example:</p>

<pre class="python">
class Caller:
    def start(self):
        obj = [1, 2, 3]
        self.remote.callRemote("both", obj, obj)
        self.remote.callRemote("deeper", ["a", obj], (4, 5, obj))

class Called(pb.Referenceable):
    def remote_both(self, arg1, arg2):
        assert arg1 is arg2
        assert arg1 == [1,2,3]
    def remote_deeper(self, listarg, tuplearg):
        ref1 = listarg[1]
        ref2 = tuplearg[2]
        assert ref1 is ref2
        assert ref1 == [1,2,3]
</pre>

<p>But if the remote-side object is referenced in two distinct remote method
invocations, the local-side methods will see two separate objects. For
example:</p>

<pre class="python">
class Caller:
    def start(self):
        self.obj = [1, 2, 3]
        d = self.remote.callRemote("one", self.obj)
        d.addCallback(self.next)
    def next(self, res):
        self.remote.callRemote("two", self.obj)

class Called(pb.Referenceable):
    def remote_one(self, ref1):
        assert ref1 == [1,2,3]
        self.ref1 = ref1

    def remote_two(self, ref2):
        assert ref2 == [1,2,3]
        assert ref1 is not ref2 # not the same object
</pre>

<p>You can think of the method call itself being a node in the object graph,
with the method arguments as its children. The method call node is picked up
and the resulting sub-tree is serialized with no knowledge of anything
outside the sub-tree<span class="footnote">This isn't quite true: for some
objects, serialization is scoped to the connection as a whole.
Referenceables and RemoteReferences are like this.</span>.</p>

<p>The value returned by a method call is serialized by itself, without
reference to the arguments that were given to the method. If a remote method
is called with a list, and the method returns its argument unchanged, the
caller will get back a deep copy of the list it passed in.</p>

<h3>Referenceables, RemoteReferences</h3>

<p>Referenceables are transformed into RemoteReferences when they are sent
over the wire. As one side traverses the object graph of the method
arguments (or the return value), each <code>Referenceable</code> object it
encounters it serialized with a <code>remote</code> sequence, that includes
the object-ID number. When the other side is unserializing the token stream,
it creates a <code>RemoteReference</code> object (TODO: or uses one that
already exists).</p>

<p>Likewise, if an argument (or return value) contains a
<code>RemoteReference</code>, and it is being sent back to the Broker that
holds the original <code>Referenceable</code> then it will be turned back
into that Referenceable when it arrives. In this case, the caller of a
remote method which returns its argument unchanged <em>will</em> see a a
result that is identical to what it passed in:</p>

<pre class="python">
class Target(pb.Referenceable):
    pass

class Caller:
    def start(self):
        self.obj = Target()
        d = self.remote.callRemote("echo", self.obj)
        d.addCallback(self.next)
    def next(self, res):
        assert res is self.obj

class Called(pb.Referenceable):
    def remote_echo(self, arg):
        # arg is a RemoteReference to a Target() instance 
        return arg
</pre>

<p>In the future, there may be other classes which behave this way. In
particular, <q>Referenceable</q> and <q>Callable</q> may be distinct
qualities.</p>

<h3>Copyable, RemoteCopy</h3>

<p>Some objects can be marked to indicate that they should be copied bodily
each time they traverse the wire. Classes which inherit from
<code>pb.Copyable</code> are passed-by-value. Their
<code>getTypeToCopy</code> and <code>getStateToCopy</code> methods are used
to assemble the data that will be serialized.</p>

<p>The receiving side must register a <code>RemoteCopy</code> subclass under
the same name as returned by the sender's <code>getTypeToCopy</code> value.

</p>

<h3>Slicers, ISlicer</h3>

<p>Each object gets <q>Sliced</q> as it goes over the wire: Referenceable
and Copyable are merely special cases. They have Slicers which implement
specific behaviors when they appear before the serialization process. You
can implement your own Slicers to do other things.</p>

<h3>Arbitrary Instances are NOT serialized</h3>

<p>Arbitrary instances (that is, anything which does not have an
<code>ISlicer</code> adapter) are <em>not</em> serialized. If an argument to
a remote method contains one, you will get a Violation exception when you
attempt to serialize it (i.e., the Deferred that you get from
<code>callRemote</code> will errback with a Failure that contains a
Violation exception). If the return value contains one, the Violation will
be logged on the local side, and the remote caller will see an error just as
if your method had raised a Violation itself.</p>

<p>There are two reasons for this. The first is a security precaution: you
must explicitly mark the classes that are willing to reveal their contents
to the world. This reduces the chance of leaking sensitive information.</p>

<p>The second is because it is not actually meaningful to send the contents
of an arbitrary object. The recipient only gets the class name and a
dictionary with the object's state. Which class should it use to create the
corresponding object? It could attempt to import one based upon the
classname (the approach pickle uses), but that would give a remote attacker
unrestricted access to classes which could do absolutely anything: very
dangerous.</p>

<p>Both ends must be willing to transport the object. The sending side
expresses this by marking the class (subclassing Copyable, or registering an
ISlicer adapter). The receiving side must register the class as well (TODO:
how?).</p>


<h2>PB Sequences</h2>

<p>There are several Banana sequences which are used to support the RPC
mechanisms of Perspective Broker. These are in addition to the usual ones
listed in the Banana <a href="banana.xhtml">docs</a>.</p>

<h3>Top-Level Sequences</h3>

<p>These sequences only appear at the top-level (never inside another
object).</p>

<table border="" width="">
  <TR><TD colspan="2">PB (method call) Sequences</TD></TR>

  <TR><TD>method call</TD>
      <TD>OPEN(call) INT(request-id) INT(obj-id) STRING(methodname)
          (STRING(argname),argvalue).. CLOSE</TD></TR>

  <TR><TD>method call++</TD>
      <TD>OPEN(call2)
        INT(reqID) INT(objID) STRING(interfacename) INT(interfaceversion)
        STRING(methodname) (STRING(argname),argvalue)..
        CLOSE
        (this could be folded into 'call' with only 2 bytes of overhead)
      </TD></TR>

  <TR><TD>method response (success)</TD>
      <TD>OPEN(answer) INT(request-id) value CLOSE</TD></TR>
  <TR><TD>method response (exception)</TD>
      <TD>OPEN(error) INT(request-id) value CLOSE</TD></TR>

  <TR><TD>RemoteReference.__del__</TD>
      <TD>OPEN(decref) INT(refID) CLOSE</TD></TR>
  
</table>

<h3>Internal Sequences</h3>

<p>The following sequences are used to serialize PB-specific objects. They
never appear at the top-level, but only as the argument value or return
value (or somewhere inside them).</p>

<table border="" width="">
  <TR><TD colspan="2">PB (method call) Sequences</TD></TR>

  <TR><TD>pb.Referenceable</TD>
      <TD>OPEN(remote) INT(ref-id)
        [InterfaceList]
        CLOSE</TD></TR>

  <TR><TD>pb.Copyable</TD><TD>OPEN(copyable) STRING(reflect.qual(class))
  (attr,value).. CLOSE</TD></TR>
  
</table>

<p>The first time a <code>pb.Referenceable</code> is sent, the second object
is an InterfaceList, which is a list of tuples of (interfacename,
versionnum), and therefore constrainable by a schema of
ListOf(TupleOf(str,int)) with some appropriate maximum-length restrictions.
This InterfaceList describes all the Interfaces that the corresponding
<code>pb.Referenceable</code> implements. The receiver uses this list to
look up local Interfaces (and therefore Schemas) to attach to the
<code>pb.RemoteReference</code>. This is how method schemas are checked on
the sender side.</p>

<p>This implies that Interfaces must be registered, just as classes are for
<code>pb.Copyable</code>. TODO: what happens if an unknown Interface is
received? TODO: are multiple versions of the same interface allowed? If so,
how is that specified?</p>

<p>Classes which wish to be passed by value should either inherit from
<code>pb.Copyable</code> or have an <code>ICopyable</code> adapter
registered for them. On the receiving side, the
<code>registerRemoteCopy</code> function must be used to register a factory,
which can be a <code>pb.RemoteCopy</code> subclass or something else which
implements <code>IRemoteCopy</code>.</p>

</body> </html>
