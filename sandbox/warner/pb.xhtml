<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<title>NewPB</title>
<style src="stylesheet-unprocessed.css"></style>
</head>

<body>
<h1>NewPB</h1>

<p>This document describes the new PB protocol. This is a layer on top of <a
href="banana.xhtml">Banana</a> which provides remote object access (method
invocation and instance transfer).</p>

<p>Fundamentally, PB is about one side keeping a
<code>RemoteReference</code> to the other side's <q>Referenceable</q>. The
Referenceable has some methods that can be invoked remotely: functionality
it is offering to remote callers. Those callers hold RemoteReferences which
point to it. The RemoteReference object offers a way to invoke those methods
(generally through the <code>callRemote</code> method).</p>

<p>There are plenty of other details, starting with how the RemoteReference
is obtained, and how arguments and return values are communicated.</p>

<p>For the purposes of this document, we will designate the side that holds
the actual <code>Referenceable</code> object as <q>local</q>, and the side
that holds the proxy <code>RemoteReference</code> object as <q>remote</q>.
This distinction is only meaningful with respect to a single
RemoteReference/Referenceable pair. One program may hold Referenceable
<q>A</q> and RemoteReference <q>B</q>, paired with another that holds
RemoteReference <q>A</q> and Referenceable <q>B</q>. Once initialization is
complete, PB is a symmetric protocol.</p>

<p>It is helpful to think of PB as providing a wire or pipe that connects
two programs. Objects are put into this pipe at one end, and something
related to the object comes out the other end. These two objects are said to
correspond to each other. Basic types (like lists and dictionaries) are
handled by Banana, but more complex types (like instances) are treated
specially, so that most of the time there is a <q>native</q> form (as
present on the local side) that goes into the pipe, and a remote form that
comes out.</p>

<h2>Initialization</h2>

<p>The PB session begins with some feature negotiation and (generally) the
receipt of a VocabularyDict. Usually this takes place over an interactive
transport, like a TCP connection, but newpb can also be used in a more
batched message-oriented mode, as long as both the creator of the method
call request and its eventual consumer are in agreement about their shared
state (at least, this is the intention.. there are still pieces that need to
be implemented to make this possible).</p>

<p>The local side keeps a table which provides a bidirectional mapping
between <code>Referenceable</code> objects and a connection-local
<q>object-ID</q> number. This table begins with a single object called the
<q>Root</q>, which is implicitly given ID number 0. Everything else is
bootstrapped through this object. For the typical PB Broker, this root
object performs cred authentication and returns other Referenceables as the
cred Avatar.</p>

<p>The remote side has a collection of <code>RemoteReference</code> objects,
each of which knows the object-ID of the corresponding Referenceable, as
well as the Broker which provides the connection to the other Broker. The
remote side must do reference-tracking of these RemoteReferences, because as
long as it remains alive, the local-side Broker must maintain a reference to
the original Referenceable.</p>

<h2>Method Calls</h2>

<p>The remote side invokes a remote method by calling
<code>ref.callRemote()</code> on its RemoteReference. This starts by
validating the method name and arguments against a <q>Schema</q> (described
below). It then creates a new Request object which will live until the
method call has either completed successfully or failed due to an exception
(including the connection being lost).</p>

<p>It then sends a <code>call</code> banana sequence over the wire. This
sequence indicates the request ID (used to match the request with the
resulting <code>answer</code> or <code>error</code> response), the object ID
of the Referenceable being targeted, a string to indicate the name of the
method being invoked, and the arguments to be passed into the method.</p>

<p>All arguments are passed by name (i.e. keyword arguments instead of
positional parameters). Each argument is subject to the <q>argument
transformation</q> described below.</p>

<p>The local side receives the <code>call</code> sequence, uses the
object-ID to look up the Referenceable, finds the desired method, then
applies the method's schema to the incoming arguments. If they are
acceptable, it invokes the method. A normal return value it sent back
immediately in an <code>answer</code> sequence. If the method returns a
Deferred, the answer will be sent back when the Deferred fires. If the
method raises an exception (or the Deferred does an errback), the resulting
Failure is sent back in a <code>error</code> sequence. Both the
<code>answer</code> and the <code>error</code> start with the request-ID so
they can be used to complete the Request object waiting on the remote
side.</p>

<h2>Argument Transformation</h2>

<p>To understand this section, it may be useful to review the <a
href="banana.xhtml">Banana</a> documentation on serializing object graphs.
Also note that method arguments and method return values are handled
identically.</p>

<p>Basic types (lists, tuples, dictionaries) are serialized and unserialized
as you would expect: the resulting object would (if it existed in the
sender's address space) compare as equal (but of course not
<q>identical</q>, because the objects will exist at different memory
locations).</p>

<h3>Shared References, Serialization Scope</h3>

<p>Shared references to the same object are handled correctly. Banana is
responsible for noticing that a sharable object has been serialized before
(or at least has begun serialization) and inserts reference markers so that
the object graph can be reconstructed. This introduces the concept of
serialization scope: the boundaries beyond which shared references are not
maintained.</p>

<p>For PB, serialization is scoped to the method call. If an object is
referenced by two arguments to the same method call, that method will see
two references to the same object. If those arguments are containers of some
form, which (eventually) hold a reference to the same object, the object
graph will be preserved. For example:</p>

<pre class="python">
class Caller:
    def start(self):
        obj = [1, 2, 3]
        self.remote.callRemote("both", obj, obj)
        self.remote.callRemote("deeper", ["a", obj], (4, 5, obj))

class Called(pb.Referenceable):
    def remote_both(self, arg1, arg2):
        assert arg1 is arg2
        assert arg1 == [1,2,3]
    def remote_deeper(self, listarg, tuplearg):
        ref1 = listarg[1]
        ref2 = tuplearg[2]
        assert ref1 is ref2
        assert ref1 == [1,2,3]
</pre>

<p>But if the remote-side object is referenced in two distinct remote method
invocations, the local-side methods will see two separate objects. For
example:</p>

<pre class="python">
class Caller:
    def start(self):
        self.obj = [1, 2, 3]
        d = self.remote.callRemote("one", self.obj)
        d.addCallback(self.next)
    def next(self, res):
        self.remote.callRemote("two", self.obj)

class Called(pb.Referenceable):
    def remote_one(self, ref1):
        assert ref1 == [1,2,3]
        self.ref1 = ref1

    def remote_two(self, ref2):
        assert ref2 == [1,2,3]
        assert ref1 is not ref2 # not the same object
</pre>

<p>You can think of the method call itself being a node in the object graph,
with the method arguments as its children. The method call node is picked up
and the resulting sub-tree is serialized with no knowledge of anything
outside the sub-tree<span class="footnote">This isn't quite true: for some
objects, serialization is scoped to the connection as a whole.
Referenceables and RemoteReferences are like this.</span>.</p>

<p>The value returned by a method call is serialized by itself, without
reference to the arguments that were given to the method. If a remote method
is called with a list, and the method returns its argument unchanged, the
caller will get back a deep copy of the list it passed in.</p>

<h3>Referenceables, RemoteReferences</h3>

<p>Referenceables are transformed into RemoteReferences when they are sent
over the wire. As one side traverses the object graph of the method
arguments (or the return value), each <code>Referenceable</code> object it
encounters it serialized with a <code>remote</code> sequence, that includes
the object-ID number. When the other side is unserializing the token stream,
it creates a <code>RemoteReference</code> object (TODO: or uses one that
already exists).</p>

<p>Likewise, if an argument (or return value) contains a
<code>RemoteReference</code>, and it is being sent back to the Broker that
holds the original <code>Referenceable</code> then it will be turned back
into that Referenceable when it arrives. In this case, the caller of a
remote method which returns its argument unchanged <em>will</em> see a a
result that is identical to what it passed in:</p>

<pre class="python">
class Target(pb.Referenceable):
    pass

class Caller:
    def start(self):
        self.obj = Target()
        d = self.remote.callRemote("echo", self.obj)
        d.addCallback(self.next)
    def next(self, res):
        assert res is self.obj

class Called(pb.Referenceable):
    def remote_echo(self, arg):
        # arg is a RemoteReference to a Target() instance 
        return arg
</pre>

<p>In the future, there may be other classes which behave this way. In
particular, <q>Referenceable</q> and <q>Callable</q> may be distinct
qualities.</p>


<h3>Copyable, RemoteCopy</h3>

<p>Some objects can be marked to indicate that they should be copied bodily
each time they traverse the wire. Classes which inherit from
<code>pb.Copyable</code> are passed-by-value. Their
<code>getTypeToCopy</code> and <code>getStateToCopy</code> methods are used
to assemble the data that will be serialized.</p>

<p>The receiving side must register a <code>RemoteCopy</code> subclass under
the same name as returned by the sender's <code>getTypeToCopy</code> value.

</p>

<h3>Slicers, ISlicer</h3>

<p>Each object gets <q>Sliced</q> as it goes over the wire: Referenceable
and Copyable are merely special cases. They have Slicers which implement
specific behaviors when they appear before the serialization process. You
can implement your own Slicers to do other things.</p>

<h3>Arbitrary Instances are NOT serialized</h3>

<p>Arbitrary instances (that is, anything which does not have an
<code>ISlicer</code> adapter) are <em>not</em> serialized. If an argument to
a remote method contains one, you will get a Violation exception when you
attempt to serialize it (i.e., the Deferred that you get from
<code>callRemote</code> will errback with a Failure that contains a
Violation exception). If the return value contains one, the Violation will
be logged on the local side, and the remote caller will see an error just as
if your method had raised a Violation itself.</p>

<p>There are two reasons for this. The first is a security precaution: you
must explicitly mark the classes that are willing to reveal their contents
to the world. This reduces the chance of leaking sensitive information.</p>

<p>The second is because it is not actually meaningful to send the contents
of an arbitrary object. The recipient only gets the class name and a
dictionary with the object's state. Which class should it use to create the
corresponding object? It could attempt to import one based upon the
classname (the approach pickle uses), but that would give a remote attacker
unrestricted access to classes which could do absolutely anything: very
dangerous.</p>

<p>Both ends must be willing to transport the object. The sending side
expresses this by marking the class (subclassing Copyable, or registering an
ISlicer adapter). The receiving side must register the class as well (TODO:
how?).</p>


<h2>PB Sequences</h2>

<p>There are several Banana sequences which are used to support the RPC
mechanisms of Perspective Broker. These are in addition to the usual ones
listed in the Banana <a href="banana.xhtml">docs</a>.</p>

<h3>Top-Level Sequences</h3>

<p>These sequences only appear at the top-level (never inside another
object).</p>

<table border="" width="">
  <TR><TD colspan="2">PB (method call) Sequences</TD></TR>

  <TR><TD>method call</TD>
      <TD>OPEN(call) INT(request-id) INT/STR(your-reference-id)
        STRING(methodname)
        (STRING(argname),argvalue)..
        CLOSE</TD></TR>

  <TR><TD>method call++</TD>
      <TD>OPEN(call2) INT(request-id) INT/STR(your-reference-id)
        STRING(interfacename) STRING(methodname)
        (STRING(argname),argvalue)..
        CLOSE
        (this could be folded into 'call' with only 2 bytes of overhead)
      </TD></TR>

  <TR><TD>method response (success)</TD>
      <TD>OPEN(answer) INT(request-id) value CLOSE</TD></TR>
  <TR><TD>method response (exception)</TD>
      <TD>OPEN(error) INT(request-id) value CLOSE</TD></TR>

  <TR><TD>RemoteReference.__del__</TD>
      <TD>OPEN(decref) INT(your-reference-id) CLOSE</TD></TR>
  
</table>

<h3>Internal Sequences</h3>

<p>The following sequences are used to serialize PB-specific objects. They
never appear at the top-level, but only as the argument value or return
value (or somewhere inside them).</p>

<table border="" width="">
  <TR><TD colspan="2">PB (method call) Sequences</TD></TR>

  <TR><TD>pb.Referenceable</TD>
      <TD>OPEN(my-reference) INT(clid)
        [OPEN(list) InterfaceList.. CLOSE]
        CLOSE</TD></TR>

  <TR><TD>pb.RemoteReference</TD>
      <TD>OPEN(your-reference) INT(clid)
        CLOSE</TD></TR>

  <TR><TD>pb.Copyable</TD><TD>OPEN(copyable) STRING(reflect.qual(class))
  (attr,value).. CLOSE</TD></TR>
  
</table>

<p>The first time a <code>pb.Referenceable</code> is sent, the second object
is an InterfaceList, which is a list of interfacename strings, and therefore
constrainable by a schema of ListOf(str) with some appropriate
maximum-length restrictions. This InterfaceList describes all the Interfaces
that the corresponding <code>pb.Referenceable</code> implements. The
receiver uses this list to look up local Interfaces (and therefore Schemas)
to attach to the <code>pb.RemoteReference</code>. This is how method schemas
are checked on the sender side.</p>

<p>This implies that Interfaces must be registered, just as classes are for
<code>pb.Copyable</code>. TODO: what happens if an unknown Interface is
received?</p>

<p>Classes which wish to be passed by value should either inherit from
<code>pb.Copyable</code> or have an <code>ICopyable</code> adapter
registered for them. On the receiving side, the
<code>registerRemoteCopy</code> function must be used to register a factory,
which can be a <code>pb.RemoteCopy</code> subclass or something else which
implements <code>IRemoteCopy</code>.</p>

<h2>Implementation notes</h2>

<h3>Outgoing Referenceables</h3>

<p>The side which holds the <code>Referenceable</code> uses a
ReferenceableSlicer to serialize it. Each <code>Referenceable</code> is
tracked with a <q>process-Unique ID</q> (abbreviated <q>puid</q>). As the
name implies, this number refers to a specific object within a given
process: it is scoped to the process (and is never sent to another process),
but it spans multiple PB connections (any given object will have the same
<code>puid</code> regardless of which connection is referring to it). The
<code>puid</code> is an integer, normally obtained with
<code>id(obj)</code>, but you can override the object's
<code>processUniqueID</code> method to use something else (this might be
useful for objects that are really proxies for something else). Any two
objects with the same <code>puid</code> are serialized identically.</p>

<p>All Referenceables sent over the wire (as arguments or return values for
remote methods) are given a <q>connection-local ID</q> (<code>clid</code>)
which is scoped to one end of the connection. The Referenceable is
serialized with this number, using a banana sequence of <code>OPEN
"my-reference" clid</code>. The remote peer (the side that holds the
<code>RemoteReference</code>) knows the Referenceable by the
<code>clid</code> sent to represent it. These are small integers. From a
security point of view, any object sent across the wire (and thus given a
<code>clid</code>) is forever accessible to the remote end (or at least
until the connection is dropped).</p>

<p>The sending side uses the <code>Broker.clids</code> dict to map
<code>puid</code> to <code>clid</code>. It uses the
<code>Broker.localObjects</code> dict to map <code>clid</code> to
<code>Referenceable</code>. The reference from <code>.localObjects</code>
also has the side-effect of making sure the Referenceable doesn't go out of
scope while the remote end holds a reference.</p>

<p><code>Broker.currentLocalID</code> is used as a counter to create
<code>clid</code> values.</p>


<h3>RemoteReference</h3>

<p>In response to the incoming <code>my-reference</code> sequence, the
receiving side creates a <code>RemoteReference</code> that remembers its
Broker and the <code>clid</code> value. The RemoteReference is stashed in
the <code>Broker.remoteReferences</code> weakref dictionary (which maps from
<code>clid</code> to <code>RemoteReference</code>), to make sure that a
single <code>Referenceable</code> is always turned into the same
<code>RemoteReference</code>. Note that this is not infallible: if the
recipient forgets about the <code>RemoteReference</code>, PB will too. But
if they really do forget about it, then they won't be able to tell that the
replacement is not the same as the original<span class="footnote">unless
they do something crazy like remembering the <code>id(obj)</code> of the old
object and check to see if it is the same as that of the new one. But
<code>id(obj)</code> is only unique among live objects anyway</span>. It
will have a different <code>clid</code>.</p>

<p>This <code>RemoteReference</code> is where the <code>.callRemote</code>
method lives. When used to invoke remote methods, the <code>clid</code> is
used as the second token of a <code>call</code> sequence. In this context,
the <code>clid</code> is a <q>your-reference</q>: it refers to the
recipient's <code>.localObjects</code> table. The
<code>Referenceable</code>-holder's <code>my-reference-id</code> is sent
back to them as the <code>your-reference-id</code> argument of the
<code>call</code> sequence.</p>

<p>The <code>RemoteReference</code> isn't always used to invoke remote
methods: it could appear in an argument or a return value instead: the goal
is to have the <code>Referenceable</code>-holder see their same
<code>Referenceable</code> come back to them. In this case, the
<code>clid</code> is put as the first token of a <code>your-reference</code>
sequence. The <code>Referenceable</code>-holder looks up the
<code>clid</code> in their <code>.localObjects</code> table and puts the
result in the method argument or return value.</p>



<h3>URL References</h3>

<p>In addition to the implicitly-created numerically-indexed
<code>Referenceable</code> instances (kept in the Broker's
<code>.localObjects</code> dict), there are explicitly-registered
string-indexed <code>Referenceable</code>s kept in the PBServerFactory's
<code>localObjects</code> dictionary. This table is used to publish objects
to the outside world. These objects are the targets of the
<code>pb.callRemoteURL</code> function.</p>

<p>To access these, a <code>RemoteReference</code> must be created that
refers to a string <code>clid</code> instead of a numeric one. This
<code>RemoteReference</code> is created manually, rather than being
generated automatically upon the receipt of a <code>my-reference</code>
sequence. The <code>pb.callRemoteURL</code> is responsible for this. It also
assumes a list of Interface names (which are usually provided by the holder
of the <code>Referenceable</code>).</p>

<p>To invoke methods on a URL-indexed object, a string token is used as the
<code>clid</code> in the <q>your-reference-id</q> argument of a
<code>call</code> sequence.</p>

<p>At present, the <code>clid</code> of a <code>your-reference</code>
sequence must be numeric: URL-indexed objects may not be used in arguments
or return values of method invocations. If the URL-indexed object returns
<code>self</code> from the method, the caller will get a regular numeric
(implicit) reference. This may change in the future as the URL-based
referencing scheme is developed. It might also become possible for string
<code>clid</code>s to appear in <code>my-reference</code> sequences, giving
<code>Referenceable</code>-holders the ability to publish URL references
explicitly.</p>

<p>It might also become possible to have these URLs point to other servers.
In this case, a <code>remote</code> sequence will probably be used, rather
than the <code>my-reference</code> sequence used for implicit
references.</p>

<p>Note that these URL-endpoints are per-Factory, so they are shared between
multiple connections (the implicitly-created references are only available
on the connection that created them). The PBServerFactory is created with a
<q>root object</q>, which is a URL-endpoint with a <code>clid</code> of an
empty string.</p>





</body> </html>
