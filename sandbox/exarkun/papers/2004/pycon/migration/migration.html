<html>
<body>

<h2>What Is Migration?</h2>

<p>Circumstances exist where it is desirable to change the behavior of a
running application without interrupting the service of those clients who
are using it at the time.  In high load environments, it is often the case
that there will always be a significant number of users relying on the
service. In these environments, the simplistic approach of waiting for the
service to become quiescent, then shutting down and restarting the server
software is not feasible.</p>

<p>Various techniques for avoiding interruptions of service have been
explored and developed ...</p>

<h2>Why Migrate?</h2>

<p></p>

<h2>Application Requirements</h2>

<p>There are several requirements made of software which is to participate in
this migration scheme.  The requirements are minimally invasive to the
application itself, but necessary for services to be migrated to a new
process.  It is for these reasons that the process of migration is referred
to as "transluscent".</p>

<p>The first requirement is that a migration server be made to listen on a
socket providing virtual circuit capabilities.  In the demonstration, a
stream oriented UNIX socket (<code>AF_UNIX</code>, <code>SOCK_STREAM</code>)
is used, but a TCP/IP socket (<code>AF_INET</code>,
<code>SOCK_STREAM</code>) would work equally as well.  When migration is to
occur, the process assuming responsibility for services will connect to this
server to initiate the migration procedure.  The server must be made aware
of all objects which represent services to be made available for migration. 
Each of these objects will be transferred to the new process separately from
the others, though typically they will all be transferred in rapid
succession.</p>

<p>The second requirement is that every object which represents a service as
well as all objects reachable from those objects must be serializable.  This
is necessary so that they can be conveyed over a socket as a stream of bytes
to the process assuming responsibility for the service (the initial
implementation of this migration technique uses
<code>twisted.spread.jelly</code> as the serialization library, however it
is not restricted to this library alone; the pickle module provides all the
necessary hooks for implementing the same functionality).  Serializers for
instances of most builtin types, including ints, strings, lists, and dicts,
are provided by framework code.  Additionally, instances of most
user-defined classes can also be serialized by using the fully qualified
name of their class and the contents of their instance
<code>__dict__</code>.  Since the focus of this migration technique is
internet servers, a serializer for file-like objects which have been wrapped
in a <code>twisted.internet.abstract.FileDescriptor</code> object is
provided as well.  This allows sockets to be migrated without special
consideration from application-level code.</p>

<p>The final requirement is that an application be able to assume
responsibility for a service from an already-running process.  As previously
mentioned, responsibility for a service is assumed by connecting to a server
running in the process which is to give up the service in question.  At this
point, a sequence of events which ultimately result in the state of one or
more services being transferred to a new process occurs.</p>

<p>First, if desired, the client can be required to authenticate with the
server, proving its identity.  While UNIX sockets already provide some level
of security with respect to who may connect to the migration server, at some
times it may be desirable to pass services to a process running as a
different user, a process which would be otherwise unable to access a socket
restricted by filesystem permissions, or a process for which filesystem
permissions alone are too coarsely grained to prevent access.</p>

<p>Second, secondary transports are established, providing a path for objects
which cannot be serialized solely as a bytestream to be transported over. 
There is one example of this in the current implementation: a second UNIX
socket is opened and used to pass file descriptors (via sendmsg(2) and
recvmsg(2)) to the process assuming responsibility.  Passing such things as
POSIX capabilities (via the same mechanism) is another use-case for UNIX
sockets as secondary transports.</p>

<p>Next, the actual migration occurs.  The client selects a service from
among those the server publishes as available for migration.  The server
serializes the service's objects and seconds them over whatever transports
are appropriate.  While the service is in transport, it is important that
parts of it not be allowed to alter state in such a way as to invalidate the
object graph received by the client.  In a network server, this typically
means that the server must cease socket related activities, such as
receiving new data from the kernel and attempting to send buffered output
data, as well as not invoking any methods on objects belonging to the
service.  It also marks the service as in-transit so that it cannot be
requests by a second migration client while it is still being sent to the
first.  Simultaneously, the client is deserializing bytes it receives and
gradually building up an object graph representing the service it has
requested.  Deserialization is straightforward, with the added requirement
that information from more than one transport may need to be combined to
produce the correct objects.  If there is an error while migrating the
service, the server can mark the service as no longer in-transit and resume
normal processing on it, resulting in no user-visible consequences of the
failure.  If the migration is successful, then the client has assumed full
responsibility for the service and the server simply discards all objects
related to that service.</p>

<p>Once all services have been migrated out of a process, the process may
terminate normally.</p>

<!-- Where does this really belong? -->

<p>It is significant to note that services can be transferred not only
between two versions of the same application, but also between otherwise
unrelated applications, so long as all the necessary unserializers are
present in the receiving application.  This has useful consequences which
will discussed further below.</p>

<h2>Serializers</h2>

<p>As previously mentioned, twisted.spread.jelly is used to communicate
objects between processes.  This implementation uses interfaces, adapters,
and components to maintain a separation of concerns between application
logic and serialization logic.  Annotated versions of the serializer and
deserializer for <code>twisted.internet.abstract.FileDescriptor</code> are
given below:</p>

<pre>
<code>
from twisted.spread import interfaces as ispread
from twisted.python import components

# Serialization

# When the jellier invokes ispread.IJellyable(obj), and obj is an instance
# of FileDescriptor, an instance of this class will be returned.
class FileDescriptorJellier(components.Adapter):
    __implements__ = (ispread.IJellyable,)

    # This is the main external entrypoint into the file descriptor
    # serialization code.  The jellier will call .jellyFor(self) on the
    # object returned by ispread.IJellyable(obj).  The object returned is an
    # s-expression representing the state of this adapted FileDescriptor
    # object.
    def jellyFor(self, jellier):
        # This is where we indicate to Twisted's reactor that this socket
        # should no longer be polled for input nor have its output buffer
        # flushed.  This ensures that state remains consistent between the
        # times when serialization begins and ends.
        self.original.stopReading()
        self.original.stopWriting()

        # The next three lines set up failure handlers, so that if there
        # is an error transferring the service this socket is part of to
        # the client, normal processing can be resumed on the server.
        a = jellier.invoker.serializingPerspective
        j = IJanitor(a)
        j.track(a.sendingServerID,
                lambda: self.original.socket.close(),
                lambda: (self.original.startReading(), self.original.startWriting()))

        # Here is where the object state is actually turned into an
        # s-expression.
        sxp = jellier.prepare(self.original)
        sxp.extend([
            reflect.qual(self.original.__class__),
            jellier.jelly(self.getStateFor(jellier))])
        return jellier.preserve(self.original, sxp)   

    # This function computes the actual instance state of the
    # FileDescriptor.
    def getStateFor(self, jellier):
        state = self.original.__dict__.copy()
        ISocketStorage(jellier).put(state.pop('socket'))

        # dChannel is the secondary transport used for transmitting file
        # descriptors.  The file descriptor is sent now, then the related
        # items of state are removed from the state dictionary.  They will
        # be re-associated with the FileDescriptor which is constructed in
        # the client process.
        jellier.invoker.serializingPerspective.dChannel.transport.sendFileDescriptors([state['fileno']()])
        del state['fileno']
        return state

# Deserialization

# Unjelliers are simpler.  They are nothing more than callables which are
# passed an unjellier object and an s-expression and which return an object.

# FileDescriptorUnjellier can work on both server ports and connected
# sockets.  The mode argument specifies which.  For server ports, the mode
# is READ.  For other sockets, it is READ | WRITE.
READ = 1
WRITE = 2

class FileDescriptorUnjellier:
    def __init__(self, mode): 
        self.mode = mode

    def __call__(self, unjellier, jellyList):
        # Unjellier.invoker.fdproto is the client's handle on the secondary
        # transport used to transfer file descriptors.
        fdproto = unjellier.invoker.fdproto

        # This is a common deserialization technique.
        klass = reflect.namedAny(jellyList[0])
        inst = _DummyClass()
        inst.__class__ = klass
        state = unjellier.unjelly(jellyList[1])
        inst.__dict__ = state

        # Here we determine what kind of socket has been transferred.
        addressFamily = getattr(klass, 'addressFamily', socket.AF_INET)
        socketType = getattr(klass, 'socketType', socket.SOCK_STREAM)  

        # Finally, we create a socket from the file descriptor and associate
        # it with the FileDescriptor that has been instantiated.

        # fdproto.fds.pop() gives the appropriate file descriptor because
        # unjellying happens in the reverse order as jellying.  For
        # serialization schemes where this does not hold, it is a simple
        # matter to include an identifier which allows the right file
        # descriptor to be found.
        skt = socket.fromfd(fdproto.fds.pop(), addressFamily, socketType)
        socketInMyPocket(skt, inst, 'socket', self.mode)
        return inst

def socketInMyPocket(skt, instance, attribute, mode):
    setattr(instance, attribute, skt)
    instance.fileno = skt.fileno
    if mode & READ:
        instance.startReading()
    if mode & WRITE:
        instance.startWriting()
</code>
</pre>

</body>
</html>
