Following IReactorTCP:
default.connectTCP:
    instantiate tcp.Connector
    call its connect method
tcp.Connector.connect:
    self.transport = self._makeTransport (which is tcp.Client for TCP)
    call factory.startedConnecting(self)
ClientFactory.startedConnecting:
    noop
tcp.Client.__init__:
    call BaseClient.createInternetSocket
    call BaseClient._finishInit
tcp.BaseClient.createInternetSocket:
    make a socket, set it to nonblocking
tcp.BaseClient._finishInit:
    
abstract.FileDescriptor provides read/write notifications and writes buffered data
(yuck, producer/consumer stuff as well)

Reactor notifies by calling overlapped.object.do_<completionkey>
Drop win32all and write my own wrapper?
Design decision: call recursive read in abstract.IoHandle or in each IoHandle
subclass? Latter, for now.

Write buffering:
None? Issue write
Some string? concat+append (this sucks)

Write complete? Adjust index, issue another write if data left, otherwise set buffer to None

Invariant! dataBuffer = None implies offset = 0

disregard for now:
    buffer is empty list:
        start writing the string
    buffer is non-empty:
        add to buffer
if buffer is None, schedule write
if not, append to buffer

