
<h2>Async Design Issues</h2>

<p>Event-driven programming still contains some tricky aspects. As each
callback must be finished as soon as possible, it is not possible to keep
persistent state in function-local variables. In addition, some programming
techniques, such as recursion, are impossible to use -- for example, this
rules out protocol handlers being recursive-descent parsers. Event-driven
programming has a reputation of being hard to use due to the frequent need to
write state machines. Twisted was built with the assumption that with the
right library, event-driven programming is easier than multi-threaded
programming.</p>

<p>In Python, code is often divided into a generic class calling
overridable methods which subclasses implement. In that, and similar,
cases, it is important to think about likely implementations. If it is
conceivable that an implementation might perform an action which takes
a long time (either because of network or CPU issues), then one should
design that method to be asynchronous. In general, this means to transform
the method to be callback based. In Twisted, it usually means returning
a <a href="defer.xhtml">Deferred</a>.</p>

<p>Since non-volatile state cannot be kept in local variables, because each
method must return quickly, it is usually kept in instance variables. In cases
where recursion would have been tempting, it is usually necessary to keep
stacks manually, using Python's list and the <code>.append</code> and
<code>.pop</code> method. Because those state machines frequently get
non-trivial, it is better to layer them such that each one state machine
does one thing -- converting events from one level of abstraction to the
next higher level of abstraction. This allows the code to be clearer, as
well as easier to debug.</p>

<h2>Using Reflection</h2>

<p>One consequence of using the callback style of programming is the
need to name small chunks of code. While this may seem like a trivial
issue, used correctly it can prove to be an advantage. If strictly
consistent naming is used, then much of the common code in parsers of
the form of if/else rules or long cases can be avoided. For example,
the SMTP client code has an instance variable which signifies what it
is trying to do. When receiving a response from the server, it just calls
the method <code>"do_%s_%s" % (self.state, responseCode)</code>. This
eliminates the requirement for registering the callback or adding to
large if/else chains. In addition, subclasses can easily override or
change the actions when receiving some responses, with no additional
harness code.  The SMTP client implementation can be found in 
<code>twisted/protocols/smtp.py</code>.</p>

<h3>Advantages of asynchrony</h3>

<p>Asynchrony has a major advantage over the threaded model of programming.
Multi-threaded programming is tricky, even with high level abstractions.
Letting the threading library decide when to give another thread a turn to do
work means that at any point another thread may interupt your thread, and your
thread will not be told. Hence, if the threads share data, there is always the
possibility that one will modify it when the other is working with it.  Design
solutions to this problem which mark pieces of data as untouchable, like the
locking abstraction, have their own traps: unless you are extremely careful,
you reintroduce blocking into your code in unexpected places.</p>

<p>Usually the threaded model has a performance advantage over the asynchrony
model on a machine with multiple CPUs or another mechanism of letting two
threads work at once. However, Python's <a
href="http://www.python.org/doc/current/api/threads.html">Global Interpreter
Lock</a> limits this potential performance gain.</p>

<p>Note that Twisted still allows the use of threads if you really need them,
usually to interface with synchronous legacy code.  See <a
href="threading.xhtml">Using Threads</a> for details.</p>

<!-- FIXME: The "let other event-driven frameworks take over the main loop"
needs to be spelled out to me before I can explain it properly.

<p>Event-driven frameworks have inherent advantages too. If you let other
event-driven frameworks take over the main loop, server and client code are
essentially the same,  -->

<p>Forking Python processes also has many disadvantages, such as Python's
reference counting not playing well with copy-on-write and problems with
shared state.  Consequently, an event-driven framework is the best overall
option for a Python networking framework.</p>

--- Example of blocking code ---
<h3>Dealing with Blocking Code</h3>

<p>When coding I/O based programs - networking code, databases,
file access - there are many APIs that are blocking, and many
methods where the common idiom is to block until a result is
gotten.</p>

<pre class="python">
class Getter:
    def getData(self, x):
        # imagine I/O blocking code here
        print "blocking"
        import time
        time.sleep(4)
        return x * 3

g = Getter()
print g.getData(3)
</pre>

--- Example of non-blocking code ---
<h3>Don't Call Us, We'll Call You</h3>

<p>Twisted cannot support blocking calls in most of its code, since it is
single threaded, and event based.  The solution for this issue is to refactor
the code, so that instead of blocking until data is available, we return
immediately, and use a callback to notify the requester once the data
eventually arrives.</p>

<pre class="python">
from twisted.internet import reactor

class Getter:
    def getData(self, x, callback):
        # this won't block
        reactor.callLater(2, callback, x * 3)

def printData(d):
    print d

g = Getter()
g.getData(3, printData)

# startup the event loop, exiting after 4 seconds
reactor.callLater(4, reactor.stop);
reactor.run()
</pre>

<p>There are several things missing in this simple example.  There is no way
to know if the data never comes back; no mechanism for handling errors.  The
example does not handle multiple callback functions, nor does it give a
method to merge arguments before and after execution.  Further, there is no
way to distinguish between different calls to gotData from different
producer objects. <code>Deferred</code> solves these problems, by creating 
a single, unified way to handle callbacks and errors from deferred
execution.</p>
