#!python
import sys
import os.path
import ConfigParser
import re

from twisted.python import usage

def qd(**kwargs): return kwargs

template = '''\
## This file was generated by tap2ntsvc, with the command line:
##   %(commandline)s

import os.path
import win32serviceutil, win32service

configfile = "%(confbase)s"
cftype = "%(type)s"
svcname = "%(name)s"
display = "%(display-name)s"
reactortype = "%(reactor)s"

class %(name)s_ServiceControl(win32serviceutil.ServiceFramework):

    _svc_name_ = svcname
    _svc_display_name_ = display

    def SvcDoRun(self):
        from twisted.application import app
        app.installReactor(reactortype)

        from twisted.application import service
        from twisted.python import log, util
        from twisted.internet import reactor


        svchome = util.sibpath(__file__, "")

        lf = file(os.path.join(svchome, "%%s.log" %% svcname), "a")
        log.startLogging(lf)

        cf = os.path.join(svchome, configfile)
        
        log.msg("Loading application from %%s" %% cf)
        
        a = service.loadApplication(cf, cftype)
        app.startApplication(a, 1)
        reactor.run()


    def SvcStop(self):
        self.ReportServiceStatus(win32service.SERVICE_STOP_PENDING)
        from twisted.internet import reactor
        reactor.stop()


if __name__ == \'__main__\':
    win32serviceutil.HandleCommandLine(%(name)s_ServiceControl)
'''

cftypes = qd(tac = 'python',
             tas = 'source',
             tax = 'xml',
             tap = 'pickle',
             )


class Tap2NtsvcOptions(usage.Options):
    optParameters = [['type', 'y', None,
                      'Config file type: pickle, xml, source, or python'],
                     ['output-file', 'o', None,
                      'Name of the setup executable produced'],
                     ['name', 'n', None,
                      'Short name of the service (used with "net start")'],
                     ['display-name', 'd', None,
                      'Human-readable name of the service'],
                     ['description', 'e', None,
                      'Description of the service'],
                     ['reactor', 'r', 'default',
                      'Reactor to install (like twistd)'],
                     ]
    
    def opt_type(self, cftype):
        if cftype not in cftypes.values():
            raise usage.UsageError("""\
Type must be one of [%s], not \"%s\"""" % (', '.join(cftypes.values()),
                                           cftype))
        self['type'] = cftype

    def parseArgs(self, conffile):
        self['conffile'] = conffile
        self['confbase'] = os.path.basename(conffile)
        ext = os.path.splitext(conffile)[1].lstrip('.')
        self['type'] = (self['type'] or  # try getting from the CL first
                        cftypes.get(ext, # then try look up by ext
                                    'pickle')) # then default pickle

    def getSynopsis(self):
        try:
            fn=__file__
        except NameError:  ## Kludge for python2.2
            fn="tap2ntsvc.py"
        return "Usage: %s [options] <filename>" % fn

    def postOptions(self):
        if not self['name']:
            self['name'] = os.path.splitext(self['conffile'])[0]
            
        if not isPythonName(self['name']):
            raise usage.UsageError("""\
\"%s\" was used for the name, but name must consist only of letters,
numbers and _.  (Use a different --name argument.)""" % self['name'])
        if not self['display-name']:
            self['display-name'] = "%s run by Twisted" % self['name']

def isPythonName(st):
    m = re.match('[A-Za-z_][A-Za-z_0-9]*', st)
    if m:
        return m.end() == len(st)
    else:
        return 0

def ini2dict(configname, section):
    cp = ConfigParser.ConfigParser()
    cp.read(configname)
    dct = {}
    for name in cp.options(section):
        dct[name] = cp.get(section, name)
    return dct


def run(argv = sys.argv):
    try:
        o = Tap2NtsvcOptions()
        o.parseOptions(argv[1:])
    except usage.UsageError, ue:
        sys.exit("%s\n** %s" % (o, ue))


    try:
        out = file("%ssvc.py" % o['name'], "w")
    except EnvironmentError:
        sys.exit("%s\n** Could not create file %ssvc.py" %
                 (o.getSynopsis(), o['name']))

    o['commandline'] = ' '.join(argv)
    out.write(template % o)

    sys.stderr.write("""\
xx TODO invoke py2exe on script
xx      generate iss file
xx      invoke Inno
""")


if __name__=='__main__':
    run()
