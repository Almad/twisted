#!/usr/bin/env python

# Twisted, the Framework of Your Internet
# Copyright (C) 2001 Matthew W. Lefkowitz
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

### Twisted Preamble
# This makes sure that users don't have to set up their environment
# specially in order to run these programs from bin/.
import sys,os,string

if string.find(os.path.abspath(sys.argv[0]),'Twisted') != -1:
    sys.path.append(os.path.dirname(
        os.path.dirname(os.path.abspath(sys.argv[0]))))
sys.path.append('.')
### end of preamble


import sys, os, re
from pprint import pprint
from twisted import copyright
from twisted.python import usage

from xml.dom import minidom as dom

def findNodes(parent, matcher, accum=None):
    if accum is None:
        accum = []
    if not hasattr(parent, 'childNodes'):
        print 'no child nodes', parent
    for child in parent.childNodes:
        # print child, child.nodeType, child.nodeName
        findNodes(child, matcher, accum)
        if matcher(child):
            accum.append(child)
    return accum

def findElements(parent, matcher):
    return findNodes(
        parent,
        lambda n, matcher=matcher: n.nodeType == dom.Element.nodeType and matcher(n))

def findElementsWithAttribute(parent, attribute, value=None):
    if value:
        return findElements(
            parent,
            lambda n, attribute=attribute, value=value: n.hasAttribute(attribute) and n.getAttribute(attribute) == value)
    else:
        return findElements(
            parent,
            lambda n, attribute=attribute: n.hasAttribute(attribute))

def findNodesNamed(parent, name):
    return findNodes(parent, lambda n, name=name: n.nodeName == name)


class Cache:
    def __init__(self, basePath, baseURL):
        self.stuff = {}
        self.basePath = basePath
        self.baseURL = baseURL
        os.path.walk(basePath, self.addFiles, None)

    def addFiles(self, arg, path, files):
#        print "adding files"
        path = path.replace(self.basePath, '')
        for file in files:
            file = os.path.join(path, file)
            module = (file.replace('.py.html', '')
                      .replace('/', '.'))

            if not file.endswith('.py.html'):
                file = file + '/index.html'
            self.stuff[module] = self.baseURL + file

    def match(self, name):
        """
        I take a fully-qualified *or* relative module or class-name, and return
        an URL to the Twisted API documentation for that name.
        """
        # Evil is fun.
        if not '.' in name:
            raise ValueError("Gimme more than just *%s* to work with, will ya?!?" % name)
        name = '.*' + name.replace('.', '[\._]') + "$"
        #print "trying", name
        pat = re.compile(name)
        for k,v in self.stuff.items():
            if pat.match(k):
                return v
                print "%s matches %s! URL: %s" % (name, k, v)



class Walker:
    def __init__(self, templ, cache, ext):
        self.templ = templ
        self.cache = cache
        self.ext = ext

    def walk(self, ig, d, names):
        linkrel = '../' * (d.count('/')-1)
        print d, "linkrel is", linkrel
        for name in names:
            fullpath = os.path.join(d, name)
            fname, fext = os.path.splitext(fullpath)
            print fname
            if fext == '.html':
                document = dom.parse(open(fullpath))
                template = self.templ.cloneNode(1)
                self.munge(document, template, linkrel)
                template.writexml(open(fname+self.ext, 'wb'))


    def munge(self, document, template, linkrel):
        # relative links
        for node in findElementsWithAttribute(template,"href"):
            node.setAttribute("href", node.getAttribute("href") + linkrel)
        for node in findElementsWithAttribute(document, "href"):
            href = node.getAttribute("href")
            if not (href.startswith("http://") or href.startswith("mailto:")):
                fname = href.split('/')[-1].split('.')
                if len(fname) == 2 and fname[1] == 'html':
                    # print 'rel link', href
                    node.setAttribute("href", fname[0] + self.ext)
        for node in findElementsWithAttribute(document, "class", "API"):
            if len(node.childNodes) > 1:
                print 'There are too many child nodes of this API link.'
            newref = self.cache.match(node.childNodes[0].nodeValue)
            if newref:
                node2 = document.createElement("a")
                node2.setAttribute("href", newref)
                node2.childNodes = node.childNodes
                node.childNodes = [node2]
                print 'api:', newref
        findNodesNamed(template, "title")[0].childNodes.extend(
            findNodesNamed(document, 'title')[0].childNodes)
        body = findNodesNamed(document, "body")[0]
        tmplbody = findElementsWithAttribute(template, "class", "body")[0]
        tmplbody.childNodes = body.childNodes
        tmplbody.setAttribute("class", "content")


class Options(usage.Options):
    synopsis = "Usage: ./generate.py [options]"
    optParameters = [["template", "t", "doc/howto/template.tpl", "The template to follow for generating content."],
                     ["version", "v", str(copyright.version), "The version of API docs to link to"],
                     ["apidir", "a", "../doc/Twisted", "The location of the API documentation generated by HappyDoc."],
                     ["docsdir", "d", "doc/howto"],
                     ["ext", "e", ".xhtml", "The extension of output files (and thus what links are munged to)"]]


def main():
    opt = Options()
    opt.parseOptions(sys.argv[1:])
    if opt['ext'] == "None":
        ext = ""
    else:
        ext = opt['ext']
    templ = dom.parse(open(opt['template']))
    c = Cache(opt['apidir'], 'http://twistedmatrix.com/documents/TwistedDocs/Twisted-%s/' % opt['version'])
    os.path.walk(opt['docsdir'], Walker(templ, c, ext).walk, None)

if __name__=='__main__':
    main()
