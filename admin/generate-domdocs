#!/usr/bin/env python

# Twisted, the Framework of Your Internet
# Copyright (C) 2001 Matthew W. Lefkowitz
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

### Twisted Preamble
# This makes sure that users don't have to set up their environment
# specially in order to run these programs from bin/.
import sys, os, string
pos = string.find(os.path.abspath(sys.argv[0]), os.sep+'Twisted')
if pos != -1:
    sys.path.insert(0, os.path.abspath(sys.argv[0])[:pos+8])
sys.path.insert(0, os.curdir)
### end of preamble


import re
import os
import cStringIO
import time
# syntax highlighting for Python source
import py2html, PyFontify
from pprint import pprint
from twisted import copyright
from twisted.python import usage

from twisted.web import microdom as dom

def findNodes(parent, matcher, accum=None):
    if accum is None:
        accum = []
    if not hasattr(parent, 'childNodes'):
        print 'no child nodes', parent
    for child in parent.childNodes:
        # print child, child.nodeType, child.nodeName
        findNodes(child, matcher, accum)
        if matcher(child):
            accum.append(child)
    return accum

def findElements(parent, matcher):
    return findNodes(
        parent,
        lambda n, matcher=matcher: isinstance(n, dom.Element) and matcher(n))

def findElementsWithAttribute(parent, attribute, value=None):
    if value:
        return findElements(
            parent,
            lambda n, attribute=attribute, value=value: n.hasAttribute(attribute) and n.getAttribute(attribute) == value)
    else:
        return findElements(
            parent,
            lambda n, attribute=attribute: n.hasAttribute(attribute))

def findNodesNamed(parent, name):
    return findNodes(parent, lambda n, name=name: n.nodeName == name)


class Cache:
    def __init__(self, basePath, baseURL):
        self.stuff = {}
        self.basePath = basePath
        self.baseURL = baseURL
        os.path.walk(basePath, self.addFiles, None)

    def addFiles(self, arg, path, files):
        path = path.replace(self.basePath, '')
        for file in files:
            file = os.path.join(path, file)
            module = (file.replace('.py.html', '')
                      .replace('/', '.'))

            self.stuff[module] = self.baseURL + file

    def match(self, name):
        """
        I take a fully-qualified *or* relative module or class-name, and return
        an URL to the Twisted API documentation for that name.
        """
        # Evil is fun.
        if not '.' in name:
            raise ValueError("Gimme more than just *%s* to work with, will ya?!?" % name)
        name = '.*' + name.replace('.', '\.') + "\.html$"
        pat = re.compile(name)
        for k,v in self.stuff.items():
            if pat.match(k):
                return v

def fontifyFiles(infile, outfile):
    py2html.PrettyPrint(PyFontify.fontify,
                        "rawhtml", "color").file_filter(infile, outfile)
    

def writeNodeData(node, oldio):
    for subnode in node.childNodes:
        if hasattr(subnode, 'data'):
            oldio.write(str(subnode.data))
        else:
            writeNodeData(subnode, oldio)
def getNodeText(node):
    oldio = cStringIO.StringIO()
    writeNodeData(node, oldio)
    return oldio.getvalue()
cols = 79

def dircount(d):
    ents = d.split("/")
    cou = 0
    for el in ents:
        if el and el != '.':
            cou += 1
    return cou

class Walker:
    def __init__(self, templ, cache, ext):
        self.templ = templ
        self.cache = cache
        self.ext = ext
        self.walked = []

    def walkdir(self, topdir):
        self.basecount = dircount(topdir)
        os.path.walk(topdir, self.walk, None)
        self.walkAround()

    def walk(self, ig, d, names):
        linkrel = '../' * (dircount(d) - self.basecount)
        for name in names:
            fullpath = os.path.join(d, name)
            fname, fext = os.path.splitext(fullpath)
            if fext == '.html':
                self.walked.append((linkrel, fname, fullpath, d))
                
    def walkAround(self):
        i = 0
        for linkrel, fname, fullpath, d in self.walked:
            i += 1
            self.percentdone((float(i) / len(self.walked)), fname)
            try:
                document = dom.parse(open(fullpath))
            except dom.MismatchedTags, e:
                print "%s:%s:%s: begin mismatched tags <%s>/</%s>" % (e.filename, e.begLine, e.begCol, e.got, e.expect)
                print "%s:%s:%s: end mismatched tags <%s>/</%s>" % (e.filename, e.endLine, e.endCol, e.got, e.expect)
                continue
            except dom.ParseError, e:
                print e
                continue
            template = self.templ.cloneNode(1)
            munge(document, template, linkrel, d, fullpath, self.ext, self.cache)
            template.writexml(open(fname+self.ext, 'wb'))
        self.percentdone(1., "*Done*")

    def percentdone(self, percent, fname):
        # override for neater progress bars
        proglen = 40
        hashes = int(percent * proglen)
        spaces = proglen - hashes
        progstat = "[%s%s] (%s)" %('#' * hashes, ' ' * spaces,fname)
        progstat += (cols - len(progstat)) * ' '
        progstat += '\r'
        sys.stdout.write(progstat)
        sys.stdout.flush()



def munge(document, template, linkrel, d, fullpath, ext, cache):
    # relative links to html files
    for node in (findElementsWithAttribute(template, "href")+
                 findElementsWithAttribute(document, "href")):
        if not node.getAttribute("class") == "html-listing":
            href = node.getAttribute("href")
            if not (href.startswith("http://") or href.startswith("mailto:")):
                fname = os.path.splitext(href)
                if len(fname) == 2 and fname[1] == '.html':
                    # print 'rel link', href
                    node.setAttribute("href", fname[0] + ext)
    for node in findElementsWithAttribute(template, "class", "mtime"):
        mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime =\
              os.stat(fullpath)
        # print mtime
        node.appendChild(dom.Text(time.asctime(time.localtime(mtime))))
    # things linked from the top
    for node in (
        findElementsWithAttribute(template,"src") +
        findElementsWithAttribute(template,"href") +
        findElementsWithAttribute(document, "fromtop")):
        if node.hasAttribute('src'):
            attr = 'src'
        else:
            attr = 'href'
        node.setAttribute(attr, linkrel+node.getAttribute(attr))

    # API references
    for node in findElementsWithAttribute(document, "class", "API"):
        if len(node.childNodes) > 1:
            print 'There are too many child nodes of this API link.'
        base = ""
        if node.hasAttribute("base"):
            base = node.getAttribute("base") + "."
        newref = cache.match(base + node.childNodes[0].nodeValue)
        if newref:
            node2 = document.createElement("a")
            node2.setAttribute("href", newref)
            node2.childNodes = node.childNodes
            node.childNodes = [node2]
    for node in findElementsWithAttribute(document, "class", "python"):
        if node.tagName == 'pre':
            newio = cStringIO.StringIO()
            # write the python code to a buffer
            oldio = cStringIO.StringIO()
            writeNodeData(node, oldio)
            oiv = oldio.getvalue()
            oivs = oiv.strip() + '\n'
            oldio = cStringIO.StringIO()
            oldio.write(oivs)
            oldio.seek(0)
            fontifyFiles(oldio, newio)
            newio.seek(0)
            newdom = dom.parse(newio)
            newel = newdom.documentElement
            newel.setAttribute("class", "python")
            node.parentNode.replaceChild(newel, node)

    for node in findElementsWithAttribute(document, "class", "py-listing"):
        fn = node.getAttribute("href")
        outfile = cStringIO.StringIO()
        fontifyFiles(open(os.path.join(d, fn)), outfile)
        val = outfile.getvalue()

        text = str('<div class="py-listing">'
                   #'<pre class="python">%s</pre>' #redundant?
                   '%s'
                   '<div class="py-caption">%s - '
                   '<span class="py-filename">%s</span></div></div>' % (
            val, getNodeText(node), node.getAttribute("href")))
        newnode = dom.parseString(text).documentElement
        node.parentNode.replaceChild(newnode, node)


    for node in findElementsWithAttribute(document, "class", "html-listing"):
        fn = node.getAttribute("href")
        val = open(os.path.join(d, fn)).read()

        #somebody please let me know if there is a better way to convert from '<' to &lt;
        import htmlentitydefs
        reverseEntityDefs = {}
        for key, value in htmlentitydefs.entitydefs.items():
            reverseEntityDefs[value]=key
        val = map(lambda x, red = reverseEntityDefs: red.has_key(x) and '&%s;' % red[x] or x, val)
        val = string.join(val, '')

        text = str('<div class="py-listing">'
                        '<pre class="htmlsource">%s</pre>'
                        '<div class="py-caption">%s - '
                        '<span class="py-filename">%s</span></div></div>' % (
                        val, getNodeText(node), node.getAttribute('href')))
        newnode = dom.parseString(text).documentElement
        node.parentNode.replaceChild(newnode, node)

    # the title
    findNodesNamed(template, "title")[0].childNodes.extend(
        findNodesNamed(document, 'title')[0].childNodes)
    body = findNodesNamed(document, "body")[0]
    tmplbody = findElementsWithAttribute(template, "class", "body")[0]
    tmplbody.childNodes = body.childNodes
    tmplbody.setAttribute("class", "content")


class Options(usage.Options):
    synopsis = "Usage: ./generate.py [options]"
    optParameters = [["template", "t", "doc/howto/template.tpl", "The template to follow for generating content."],
                     ["version", "v", str(copyright.version), "The version of API docs to link to"],
                     ["apidir", "a", "doc/api", "The location of the API documentation generated by epydoc."],
                     ["docsdir", "d", "doc/howto"],
                     ["ext", "e", ".xhtml", "The extension of output files (and thus what links are munged to)"]]

    def parseArgs(self, *files):
        self['files'] = files
        if files:
            #silly kludge
            if self['docsdir'] == 'doc/howto':
                self['docsdir'] = '.'
            if self['template'] == 'doc/howto/template.tpl':
                self['template'] = 'template.tpl'


def main():
    opt = Options()
    try:
        opt.parseOptions(sys.argv[1:])
    except usage.UsageError, errortext:
        print '%s: %s' % (sys.argv[0], errortext)
        print '%s: Try --help for usage details.' % (sys.argv[0])
        sys.exit(1)
    if opt['ext'] == "None":
        ext = ""
    else:
        ext = opt['ext']
    templ = dom.parse(open(opt['template']))
    print "getting apidocs from", opt['apidir']
    c = Cache(opt['apidir'], 'http://twistedmatrix.com/documents/TwistedDocs/Twisted-%s/' % opt['version'])
    if opt['files']:
        for fn in opt['files']:
            try:
                doc = dom.parse(open(fn))
            except dom.MismatchedTags, e:
                print "%s:%s:%s: begin mismatched tags <%s>/</%s>" % (e.filename, e.begLine, e.begCol, e.got, e.expect)
                print "%s:%s:%s: end mismatched tags <%s>/</%s>" % (e.filename, e.endLine, e.endCol, e.got, e.expect)
                continue
            except dom.ParseError, e:
                print e
                continue
            cn = templ.cloneNode(1)
            munge(doc, cn, '', opt['docsdir'], fn, ext, c)
            cn.writexml(open(os.path.splitext(fn)[0]+ext, 'wb'))
    else:
        w = Walker(templ, c, ext)
        w.walkdir(opt['docsdir'])
    print

if __name__=='__main__':
    main()
