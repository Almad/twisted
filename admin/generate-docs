#!/usr/bin/env python

# Twisted, the Framework of Your Internet
# Copyright (C) 2001 Matthew W. Lefkowitz
#
# This library is free software; you can redistribute it and/or
# modify it under the terms of version 2.1 of the GNU Lesser General Public
# License as published by the Free Software Foundation.
#
# This library is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

### Twisted Preamble
# This makes sure that users don't have to set up their environment
# specially in order to run these programs from bin/.
import sys,os,string

if string.find(os.path.abspath(sys.argv[0]),'Twisted') != -1:
    sys.path.append(os.path.dirname(
        os.path.dirname(os.path.abspath(sys.argv[0]))))
sys.path.append('.')
### end of preamble

#
# The Simplest Thing that could Possibly Work, part two. 
#
# No docs. I want to keep my job.
#

import os, time, sgmllib, re, string, sys, cgi, cStringIO, glob, types

from twisted.python import usage
from twisted import copyright


cssclassmap =  {'services': 'serv-text',
                'documents': 'doc-text',
                'developers': 'dev-text',
                'products': 'prod-text'}

DO_NOT_CHANGE = 1

class TemplateFilter(sgmllib.SGMLParser):
    def __init__(self, file, APICache):
        sgmllib.SGMLParser.__init__(self)
        self.io = cStringIO.StringIO()
        self.titleMode = 1
        self.title = []
        self.apiLink = 0
        self.APICache = APICache
        while 1:
            s = file.read(1024)
            if not s: break
            self.feed(s)
        self.close()


    def unknown_starttag(self, tag, attrs):
        result = self.start(tag, attrs)
        if result == DO_NOT_CHANGE:
            #if we don't munge it, then it should be exactly the same
            t = self.get_starttag_text()
            #print "writing",t,"untouched."
            self.io.write(t)
            return
        self.io.write(result)

    def unknown_endtag(self, tag):
        self.io.write(self.end(tag))

    def handle_entityref(self, name):
        self.io.write("&%s;" % name)

    def generate_tag(self, tag, attrs):
        if not attrs:
            return "<%s>" % tag
        else:
            o = "<%s" % tag
            for k,v in attrs:
                o += " %s=%s" % (k,repr(v))
            o += ">"
            return o

    def handle_data(self, data):
        if self.apiLink:
            url = self.APICache.match(data)
            if url:
                data = '<a href="%s">%s</a>' % (url, data)
        if self.titleMode:
            self.title.append(data)
        
        self.io.write(data)


    def start(self, tag, attrs):
        if tag in ('br', 'hr'):
            return DO_NOT_CHANGE
        
        if tag == 'title':
            self.titleMode = 1
            return DO_NOT_CHANGE

        if tag == 'a':
            #If it's a relative link, we have to replace '.html' with ''.
            for i in range(len(attrs)):
                attr = attrs[i]
                if attr[0] == 'href':
                    if ((not attr[1].find(":") >= 0) and
                    (not attr[1].startswith('..')) and
                    (not attr[1].startswith('/'))):
                        #print "relative!", attrs,
                        attrs[i] = ('href', attr[1].replace('.html', ''))
                        #print "returning", attrs
                        return self.generate_tag(tag,attrs)

        for i in range(len(attrs)):
            attr = attrs[i]
            if attr[0] == 'class':
                if string.lower(attr[1]) == 'api':
                    self.apiLink = tag
                    
        return DO_NOT_CHANGE

    def end(self, tag):
        #print "end",tag
        if tag == 'title':
            self.titleMode = 0
            self.title = string.join(self.title, "")
            #print "got title", self.title
            #        print tag
        if tag == self.apiLink:
            self.apiLink = 0
        return "</%s>" % tag



    def get_title(self):
        assert isinstance(self.title, types.StringType), "Hmm. Something's wrong with the <title> of this document."
        return self.title

class Walker:
    def __init__(self, templ, cache):
        self.shwackBeginning = re.compile('.*<body.*?>', re.MULTILINE | re.I)
        self.shwackEnd = re.compile('</body>.*', re.MULTILINE | re.I)
        self.templ = templ
        self.APICache = cache

    def walk(self, ig, d, names):
        linkrel = '../' * (d.count('/')-1)
        print d, "linkrel is", linkrel
        for name in names:
            fname, fext = os.path.splitext(os.path.join(d, name))

            # begin .htc processing
            if fext == '.html':
                print fname + fext
                inFile = open(fname+fext)
                filt = TemplateFilter(inFile, self.APICache)
                title = filt.get_title()
                data = filt.io.getvalue()
                start = self.shwackBeginning.search(data)
                end = self.shwackEnd.search(data)
                #hee hee!
                if start:
                    start = start.end()
                
                if end:
                    end = end.start()
                
                data = data[start:end]

                outFile = open(fname,'wb')
                p = d.split('/')
                cssclass = (len(p) > 1 and cssclassmap.get(p[1])) or 'content'
                #perform translations and interpolations
                data = (self.templ
                        .replace('@@',linkrel)
                        .replace(',@title', title)
                        .replace(',@class', cssclass)
                        .replace(',@content', data)
                        .replace(',@hhmts', time.ctime(os.path.getmtime(fname+fext))))
                outFile.write(data)
                
                outFile.flush()
                outFile.close()



class Cache:
    def __init__(self, basePath, baseURL):
        self.stuff = {}
        self.basePath = basePath
        self.baseURL = baseURL
        os.path.walk(basePath, self.addFiles, None)

    def addFiles(self, arg, path, files):
#        print "adding files"
        path = path.replace(self.basePath, '')
        for file in files:
            file = os.path.join(path, file)
            module = (file.replace('.py.html', '')
                      .replace('/', '.'))

            if not file.endswith('.py.html'):
                file = file + '/index.html'
            self.stuff[module] = self.baseURL + file

    def match(self, name):
        """
        I take a fully-qualified *or* relative module or class-name, and return an URL to the Twisted API documentation for that name.
        """
        # Evil is fun.
        if not '.' in name:
            raise ValueError("Gimme more than just *%s* to work with, will ya?!?" % name)
        name = '.*' + name.replace('.', '[\._]') + "$"
        #print "trying", name
        pat = re.compile(name)
        for k,v in self.stuff.items():
            if pat.match(k):
                return v
                print "%s matches %s! URL: %s" % (name, k, v)
        
                  

class Options(usage.Options):
    synopsis = "Usage: ./generate.py [options]"
    optParameters = [["template", "t", "doc/howto/template.tpl", "The template to follow for generating content."],
                     ["version", "v", str(copyright.version), "The version of API docs to link to"],
                     ["apidir", "a", "TwistedDocs-0.15.5/Twisted-0.15.5", "The location of the API documentation generated by HappyDoc."],
                     ["docsdir", "d", "doc/howto"]]

def main():
    opt = Options()
    opt.parseOptions(sys.argv[1:])
    cache = Cache(opt.apidir, 'http://twistedmatrix.com/documents/TwistedDocs/Twisted-%s/' % opt.version)

    templ = open(opt.template).read()

    os.path.walk(opt.docsdir, Walker(templ, cache).walk, None)

if __name__=='__main__':
    main()
